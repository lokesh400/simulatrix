<!doctype html>
<html>

<head>
    <title>Screw Gauge</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            background: white;
            color: #323232;
            font-weight: 300;
            height: 100vh;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-family: Helvetica neue, roboto;
        }

        img {
            width: 56px;
            height: 48px;
        }

        h1 {
            font-weight: 200;
            margin: 10px;
        }

        #container canvas {
            position: relative;
            touch-action: none;
        }

        #container #overlay {
            position: absolute;
        }

        .hover_bkgr_fricc {
            background: rgba(0, 0, 0, .4);
            cursor: pointer;
            display: none;
            height: 100%;
            position: fixed;
            text-align: center;
            top: 0;
            width: 100%;
            z-index: 10000;
        }

        .hover_bkgr_fricc .helper {
            display: inline-block;
            height: 100%;
            vertical-align: middle;
        }

        .hover_bkgr_fricc>div {
            background-color: #fff;
            box-shadow: 10px 10px 60px #555;
            display: inline-block;
            height: auto;
            max-width: 551px;
            min-height: 100px;
            vertical-align: middle;
            width: 60%;
            position: relative;
            border-radius: 8px;
            padding: 15px 5%;
        }

        .popupCloseButton {
            background-color: #fff;
            border: 3px solid #999;
            border-radius: 50px;
            cursor: pointer;
            display: inline-block;
            font-family: arial;
            font-weight: bold;
            position: absolute;
            top: -20px;
            right: -20px;
            font-size: 25px;
            line-height: 30px;
            width: 30px;
            height: 30px;
            text-align: center;
        }

        .popupCloseButton:hover {
            background-color: #ccc;
        }

        .trigger_popup_fricc {
            background-color: #fff;
            border: 3px solid #999;
            border-radius: 50px;
            cursor: pointer;
            font-size: 20px;
            position: absolute;
            font-family: arial;
            font-weight: bold;
            position: absolute;
            top: 5px;
            left: 5px;
            z-index: 2;
            margin: 10px;
            display: inline-block;
            font-weight: bold;
            right: -20px;
            font-size: 25px;
            line-height: 30px;
            width: 30px;
            height: 30px;
            text-align: center;
        }

        #gui {
            font-size: 15px;
            position: absolute;
            font-family: arial;
            transform: scale(1.2);
            transform-origin: top right;
            font-weight: bold;
            position: absolute;
            right: 5px;
            margin-left: auto;
            z-index: 2;
            font-weight: bold;
            font-size: 25px;
        }

        /* Touch-friendly rotation slider */
        .rotation-control {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 15px 20px;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .rotation-control h3 {
            color: white;
            margin: 0 0 10px 0;
            font-size: 14px;
            text-align: center;
            font-weight: 500;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            min-width: 300px;
        }

        .rotation-slider {
            flex: 1;
            height: 8px;
            background: linear-gradient(to right, #ff4444, #ffaa00, #44ff44, #00aaff, #4444ff);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .rotation-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border: 2px solid #333;
            transition: all 0.2s ease;
        }

        .rotation-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .rotation-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border: 2px solid #333;
            transition: all 0.2s ease;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            margin-top: 5px;
        }

        .rotation-buttons {
            display: flex;
            gap: 10px;
        }

        .rotation-btn {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            user-select: none;
        }

        .rotation-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
        }

        .rotation-btn:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.3);
        }

        .reading-display {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px 12px;
            margin-top: 10px;
            text-align: center;
        }

        .reading-display .main-reading {
            color: #4CAF50;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 2px;
        }

        .reading-display .sub-reading {
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
        }

        /* Hide on very small screens */
        @media (max-width: 480px) {
            .rotation-control {
                left: 10px;
                right: 10px;
                transform: none;
            }

            .slider-container {
                min-width: auto;
            }
        }

        :root {
            --tp-base-background-color: hsla(200, 6%, 15%, 0.8);
            --tp-base-shadow-color: hsla(0, 0%, 0%, 0.26);
            --tp-button-background-color: hsla(230, 7%, 70%, 1.00);
            --tp-button-background-color-active: hsla(229, 7%, 55%, 1.00);
            --tp-button-background-color-focus: hsla(231, 7%, 60%, 1.00);
            --tp-button-background-color-hover: hsla(230, 7%, 65%, 1.00);
            --tp-button-foreground-color: hsla(230, 7%, 20%, 1.00);
            --tp-container-background-color: hsla(230, 7%, 75%, 0.10);
            --tp-container-background-color-active: hsla(230, 7%, 75%, 0.25);
            --tp-container-background-color-focus: hsla(230, 7%, 75%, 0.20);
            --tp-container-background-color-hover: hsla(230, 7%, 75%, 0.15);
            --tp-container-foreground-color: hsla(230, 7%, 75%, 1.00);
            --tp-groove-foreground-color: hsla(230, 7%, 0%, 0.20);
            --tp-input-background-color: hsla(230, 0%, 0%, 0.55);
            --tp-input-background-color-active: hsla(230, 7%, 0%, 0.35);
            --tp-input-background-color-focus: hsla(230, 7%, 0%, 0.30);
            --tp-input-background-color-hover: hsla(230, 7%, 0%, 0.25);
            --tp-input-foreground-color: hsla(230, 9%, 81%, 1.00);
            --tp-label-foreground-color: hsla(230, 6%, 83%, 0.70);
            --tp-monitor-background-color: hsla(230, 7%, 0%, 0.20);
            --tp-monitor-foreground-color: hsla(230, 7%, 75%, 0.70);
        }
    </style>
    <script src="./hammer.js"></script>
    <script src="./tweakpane3.js"></script>
</head>

<body>
    <div class="container">
        <div id="gui" style="position: absolute">
        </div>
        <canvas id="myCanvas" style="border: 1px solid #c3c3c3;">
            Your browser does not support the HTML5 canvas tag.
        </canvas>
        <a class="trigger_popup_fricc"></a>
            <div class="hover_bkgr_fricc">
                <div>
                    <div class="popupCloseButton">&times;</div>
                </div>
        </div>
    </div>

    <!-- Touch-friendly rotation control -->
    <div class="rotation-control" id="rotationControl">
        <h3>üîß Thimble Rotation Control</h3>
        <div class="slider-container">
            <div class="rotation-buttons">
                <button class="rotation-btn" id="rotateLeft" title="Rotate Left">‚Üê</button>
            </div>
            <div style="flex: 1;">
                <input type="range" class="rotation-slider" id="rotationSlider" min="0" max="1000" value="500" step="1">
                <div class="slider-labels">
                    <span>Close</span>
                    <span>Center</span>
                    <span>Open</span>
                </div>
            </div>
            <div class="rotation-buttons">
                <button class="rotation-btn" id="rotateRight" title="Rotate Right">‚Üí</button>
            </div>
        </div>
        <div class="reading-display">
            <div class="main-reading" id="mainReading">0.000 mm</div>
            <div class="sub-reading" id="subReading">MSR: 0 | CSR: 0</div>
        </div>
    </div>
    <script type='text/javascript'>
        var scale;
        var xOffset = 0;
        var yOffset = 0;
        var dragMode = 0;
        var mx, my;
        var bgColor = "rgb(0,0,0)";
        var fgColor = "red"
        var loadedItems = 0;
        const itemsToLoad = 4;
        var imgThimble = new Image();
        imgThimble.src = "thimble.png"
        imgThimble.onload = itemloaded;
        var imgSpindle = new Image();
        imgSpindle.src = "spindle.png"
        imgSpindle.onload = itemloaded;
        var imgBase = new Image();
        imgBase.src = "micrometer_base.png"
        imgBase.onload = itemloaded;
        var imgTexture = new Image();
        imgTexture.src = "texture9.png"
        imgTexture.onload = itemloaded;
        var textPattern = null;
        var gradient = null;
        var tickSound = new Audio("tick.wav");
        tickSound.onload = itemloaded;
        const scaleOriginX = 539;
        const scaleOriginY = 100;
        const spindleOriginX = 200;
        const spindleOriginY = 79;
        const thimbleY1 = 49;
        const thimbleY2 = 40;
        const thimbleY3 = 31;
        const thimbleX1 = 0;
        const thimbleX2 = 40;
        const thimbleX3 = 440;
        const unit = "mm";
        const mainScaleLengthPixels = 200;
        const majorTickLengthPixels = 20;
        const minorTickLengthPixels = 10;
        const vernierMajorTickLengthPixels = 30;
        const vernierMinorTickLengthPixels = 18;
        const scaleColor = "black";
        var mainScaleDivisions = 30;
        var msd_pixels = mainScaleLengthPixels / mainScaleDivisions;
        var msdValue = 0.5;
        var circularScaleDivisions = 50;
        var msr = 0;
        var csr = 0;
        var zeroError = 0;
        var displayInfo = false;
        var objectWidthPixel = 25;
        var precision;
        var randomZeroError = true;
        var randomMainScaleDivisions = true;
        var randomCircularScaleDivision = true;
        var randomObjectWidthPixel = true;
        var objectTobeMeasured = {
            x: xOffset + window.innerWidth - 100,
            y: yOffset + window.innerHeight - 110,
            w: 30,
            h: 100,
            state: 1
        };
        const pane = new Tweakpane.Pane({
            container: document.getElementById("gui"),
            title: "Micrometer Settings"
        });
        const tab = pane.addTab({
            pages: [{
                title: 'Device settings'
            },
            {
                title: 'Create Problem'
            },
            ],
        });
        tab.pages[0].addInput(window, "msdValue", {
            label: "MSD",
            min: 0.05,
            max: 5,
            step: 0.5
        }).on('change', update);
        tab.pages[0].addInput(window, "mainScaleDivisions", {
            label: "MSD Count",
            min: 10,
            max: 50,
            step: 10
        }).on('change', update);
        var csController = tab.pages[0].addInput(window,
            "circularScaleDivisions", {
            label: "CSD Count",
            min: 25,
            max: 100,
            step: 25
        });
        csController.on('change', update);
        var zeController = tab.pages[0].addInput(window, "zeroError", {
            label: "Zero Error",
            min: -circularScaleDivisions + 1,
            max: circularScaleDivisions - 1,
            step: 1
        });
        zeController.on('change', update);
        tab.pages[0].addInput(window, "displayInfo", {
            label: "Display values"
        }).on('change', update);
        tab.pages[0].addInput(window, "bgColor", {
            label: "Background",
            picker: 'inline'
        }).on('change', paint);
        var problemFolder = tab.pages[1].addFolder({
            title: "Check to randomize"
        });
        problemFolder.addInput(window, "randomZeroError", {
            label: "Zero Error"
        });
        problemFolder.addInput(window, "randomMainScaleDivisions", {
            label: "MSD Count"
        });
        problemFolder.addInput(window, "randomCircularScaleDivision", {
            label: "CSD Count"
        });
        problemFolder.addInput(window, "randomObjectWidthPixel", {
            label: "Object's Size"
        });
        tab.pages[1].addButton({
            title: "createProblem"
        }).on('click', createProblem);
        var canvas = document.getElementById("myCanvas");
        canvas.width = window.innerWidth * devicePixelRatio;
        canvas.height = window.innerHeight * devicePixelRatio;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        scale = (canvas.width / 1500);
        var ctx = canvas.getContext("2d");
        ctx.font = "30px Arial";
        // ensure canvas doesn't perform default touch actions
        try { canvas.style.touchAction = 'none'; } catch (e) { }
        // track whether Hammer has been initialized to avoid duplicate handling
        window.hammerEnabled = false;
        // Add basic touch/pointer handlers; they early-return when Hammer is active
        canvas.addEventListener('touchstart', function (e) { if (window.hammerEnabled) return; myTouchStart(e); }, { passive: false });
        canvas.addEventListener('touchmove', function (e) { if (window.hammerEnabled) return; myTouchMove(e); }, { passive: false });
        canvas.addEventListener('touchend', function (e) { if (window.hammerEnabled) return; myTouchEnd(e); }, { passive: false });

        canvas.addEventListener('pointerdown', function (e) {
            if (window.hammerEnabled) return;
            const mouseEvent = new MouseEvent('mousedown', { clientX: e.clientX, clientY: e.clientY });
            mousePressed(mouseEvent);
        });
        canvas.addEventListener('pointermove', function (e) {
            if (window.hammerEnabled) return;
            const mouseEvent = new MouseEvent('mousemove', { clientX: e.clientX, clientY: e.clientY });
            mouseDragged(mouseEvent);
        });
        canvas.addEventListener('pointerup', function (e) {
            if (window.hammerEnabled) return;
            const mouseEvent = new MouseEvent('mouseup', { clientX: e.clientX, clientY: e.clientY });
            mouseReleased(mouseEvent);
        });
        window.addEventListener('resize', function (ev) {
            return resize(ev);
        });
        var hammertime;
        paint();
        var intiScale = scale;
        tab.pages[0].addInput(window, "scale", {
            label: "Scale",
            min: 0.5,
            max: 3,
            step: 0.1
        }).on('change', update);
        function itemloaded() {
            loadedItems++;
            if (loadedItems == itemsToLoad) {
                hammertime = new Hammer(canvas);
                hammertime.get('pinch').set({
                    enable: true
                });
                hammertime.get('pan').set({
                    direction: Hammer.DIRECTION_ALL,
                    threshold: 0,
                });
                hammertime.on('panstart', function (ev) {
                    let mouseEvent = new MouseEvent("mousedown", {
                        clientX: ev.center.x,
                        clientY: ev.center.y
                    });
                    mousePressed(mouseEvent);
                });
                hammertime.on('panend', function (ev) {
                    let mouseEvent = new MouseEvent("mouseup", {
                        clientX: ev.center.x,
                        clientY: ev.center.y
                    });
                    mouseReleased(mouseEvent);
                });
                hammertime.on('panmove', function (ev) {
                    let mouseEvent = new MouseEvent("mousemove", {
                        clientX: ev.center.x,
                        clientY: ev.center.y
                    });
                    mouseDragged(mouseEvent);
                });
                hammertime.on('pinchstart', function (ev) {
                    intiScale = scale;
                });
                hammertime.on('pinch', function (ev) {
                    console.log(ev.type + " scale=" + ev.scale);
                    let oldScale = scale;
                    let x = ev.center.x / scale;
                    let y = ev.center.y / scale;
                    scale = intiScale * ev.scale;
                    xOffset -= x * (scale - oldScale);
                    yOffset -= y * (scale - oldScale);
                    paint();
                });
                // mark Hammer as active so fallback handlers ignore duplicate events
                window.hammerEnabled = true;
                canvas.addEventListener("mousewheel", mouseWheelMoved);
                window.addEventListener('keydown', onKeyEvent, false);

                // Setup slider controls
                setupSliderControls();

                document.querySelector(".trigger_popup_fricc").onclick =
                    function () {
                        document.querySelector('.hover_bkgr_fricc').style
                            .display = "block";
                    };
                document.querySelector('.hover_bkgr_fricc').onclick =
                    function () {
                        document.querySelector('.hover_bkgr_fricc').style
                            .display = "none";
                    };
                document.querySelector('.popupCloseButton').onclick =
                    function () {
                        document.querySelector('.hover_bkgr_fricc').style
                            .display = "none";
                    };
            }
            paint();
        }
        function resize() {
            if (window.innerWidth < 10 || window.innerHeight < 10) return;
            canvas.width = window.innerWidth * devicePixelRatio;
            canvas.height = window.innerHeight * devicePixelRatio;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            scale *= (window.innerWidth / canvas.width);
            pane.refresh();
        }
        init();
        function init() {
            resize();
        }
        function createProblem() {
            if (randomCircularScaleDivision) circularScaleDivisions = (1 + Math
                .round(Math.random() * 3)) * 25;
            if (randomZeroError) zeroError = Math.round(2 *
                circularScaleDivisions * (Math.random() - 0.5));
            if (randomMainScaleDivisions) mainScaleDivisions = 10 * (1 + Math
                .round(4 * Math.random()));
            if (randomObjectWidthPixel) objectWidthPixel =
                mainScaleLengthPixels * (1 + 5 * Math.random()) / 10;
            objectTobeMeasured.state = 1;
            objectTobeMeasured.w = objectWidthPixel;
            objectTobeMeasured.x = 20;
            objectTobeMeasured.y = 20;
            if (Math.abs(objectTobeMeasured.x - spindleOriginX) < 200 && Math
                .abs(objectTobeMeasured.y - scaleOriginY + objectTobeMeasured
                    .h / 2) < objectTobeMeasured.h / 2 + 50) {
                objectTobeMeasured.x = spindleOriginX;
                objectTobeMeasured.y = scaleOriginY - objectTobeMeasured.h / 2;
                objectTobeMeasured.state = 2;
            } else if (objectTobeMeasured.x > canvas.width - objectTobeMeasured
                .w || objectTobeMeasured.y > canvas.height - objectTobeMeasured
                    .w || objectTobeMeasured.x < objectTobeMeasured.w / 2 ||
                objectTobeMeasured.y < -objectTobeMeasured.h / 2) {
                objectTobeMeasured.x =
                    20;
                objectTobeMeasured.y =
                    20;
            }
            pane.refresh();
            rotateVernier(0);
        }
        var lastTickTime = 0;

        function rotateVernier(div) {
            let oldCSR = csr;
            let oldMSR = msr;

            csr += div;
            if (csr < 0) {
                csr = circularScaleDivisions + csr;
                msr -= 1;
            } else if (csr >= circularScaleDivisions) {
                csr = csr - circularScaleDivisions;
                msr += 1;
            }
            let correctedReading = getCorrectedReading();
            if (correctedReading <= 0) {
                msr = 0;
                csr = 0;
                playTickSound();
            }
            if (correctedReading >= mainScaleDivisions * msdValue) {
                msr = mainScaleDivisions;
                csr = 0;
                playTickSound();
            }

            // Play tick sound for every 5 divisions or MSR change for better feedback
            if (Math.abs(csr - oldCSR) >= 5 || msr != oldMSR) {
                playTickSound();
            }

            if (objectWidthPixel != 0) {
            }
            update();
        }

        function playTickSound() {
            let currentTime = Date.now();
            if (currentTime - lastTickTime > 50) { // Throttle sound to prevent overlap
                tickSound.muted = false;
                tickSound.currentTime = 0; // Reset to beginning
                if (tickSound.paused) tickSound.play();
                lastTickTime = currentTime;
            }
        }
        function update() {
            msd_pixels = mainScaleLengthPixels / mainScaleDivisions;
            precision = (circularScaleDivisions % 3 == 0 ||
                circularScaleDivisions % 7 == 0) ? 3 : 2;
            if (objectTobeMeasured.state == 2) {
                let v = (msr + csr / circularScaleDivisions) * msd_pixels
                if (v < objectTobeMeasured.w) {
                    msr = Math.floor(objectTobeMeasured.w / msd_pixels);
                    csr = Math.floor((objectTobeMeasured.w / msd_pixels - msr) *
                        circularScaleDivisions);
                    if (tickSound.paused) tickSound.play();
                }
            }
            paint();
        }
        function paint() {
            ctx.lineWidth = 1.5;
            ctx.fillStyle = bgColor;
            ctx.strokeStyle = fgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (loadedItems < itemsToLoad) {
                ctx.font = "30px Arial";
                ctx.fillStyle = fgColor;
                outString(canvas.width / 2, canvas.height / 2, "Loading ..." + (
                    loadedItems * 100 / itemsToLoad).toFixed(0) + "%",
                    1, 1);
                return;
            }
            ctx.scale(scale * devicePixelRatio, scale * devicePixelRatio);
            ctx.translate(xOffset, yOffset);
            ctx.save();
            //draw  Spindle first
            let shift = (msr + csr / circularScaleDivisions) * msd_pixels;
            ctx.drawImage(imgSpindle, spindleOriginX + shift, spindleOriginY);
            //draw Base of gauge
            ctx.drawImage(imgBase, 0, 0);
            //draw ruler on main scale
            ctx.translate(scaleOriginX, scaleOriginY);
            //Rectangle2D.Double rect = new Rectangle2D.Double(Xoffset,Yoffset,mainscaleWidth,mainscaleHeight);
            ctx.fillStyle = scaleColor; //"rgb(210,210,210)";
            ctx.strokeStyle = scaleColor;
            let x = -msd_pixels * zeroError / circularScaleDivisions,
                y = 0,
                ticklength = 0;
            ctx.font = '12pt sans-serif';
            //ctx.strokeStyle="orange";
            let drawLowerTicks = mainScaleDivisions > 20;
            for (let i = 0; i <= mainScaleDivisions; i++) {
                ticklength = (i % 5 == 0) ? majorTickLengthPixels :
                    minorTickLengthPixels;
                if (drawLowerTicks && i % 2 == 1) ticklength = -
                    minorTickLengthPixels;
                drawLine(x, y, x, y - ticklength);
                if (i % 10 == 0) outString(x, (y - ticklength - 3), i *
                    msdValue, 1, 2);
                x += msd_pixels;
            }
            ctx.restore();
            ctx.save();
            ctx.fillStyle = "rgb(156,172,156)";
            ctx.font = '12pt sans-serif';
            //draw Circular scale
            let N = circularScaleDivisions / 4;
            let R = scaleOriginY - thimbleY1;
            ctx.drawImage(imgThimble, scaleOriginX + shift, thimbleY3);

            // Add visual rotation indicator on thimble
            let thimbleIndicatorX = scaleOriginX + shift + thimbleX2 + (thimbleX3 - thimbleX2) / 2;
            let thimbleIndicatorY = scaleOriginY;
            let indicatorRadius = (scaleOriginY - thimbleY3) * 0.8;
            let rotationAngle = (csr / circularScaleDivisions) * 2 * Math.PI;

            // Draw rotation indicator line
            ctx.save();
            ctx.strokeStyle = "rgba(255, 100, 100, 0.8)";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(thimbleIndicatorX, thimbleIndicatorY);
            ctx.lineTo(thimbleIndicatorX + Math.cos(rotationAngle) * indicatorRadius,
                thimbleIndicatorY + Math.sin(rotationAngle) * indicatorRadius);
            ctx.stroke();

            // Draw center dot
            ctx.fillStyle = "rgba(255, 100, 100, 0.8)";
            ctx.beginPath();
            ctx.arc(thimbleIndicatorX, thimbleIndicatorY, 3, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();

            ctx.rect(scaleOriginX + shift, thimbleY3, (thimbleX3 - thimbleX2 -
                153), 2 * (scaleOriginY - thimbleY3 - 1));
            // ctx.clip();
            if (textPattern == null) {
                textPattern = ctx.createPattern(imgTexture, 'repeat');
            }
            let offsetY = (msr * circularScaleDivisions + csr) * R * Math.PI /
                N / 2;
            let s = 1;
            ctx.fillStyle = textPattern;
            ctx.scale(s, s);
            ctx.translate(scaleOriginX + shift + thimbleX2 + 49, scaleOriginY +
                offsetY / s);
            R = scaleOriginY - thimbleY3;
            ctx.fillRect(0, -(R + offsetY) / s, (thimbleX3 - thimbleX2 - 153) /
                s, 2 * R / s);
            ctx.restore();
            ctx.save();
            if (gradient == null) {
                gradient = ctx.createLinearGradient(thimbleX2, thimbleY3,
                    thimbleX2, thimbleY3 + 2 * R);
                gradient.addColorStop(0, "black"); //rgb(46,57,46)");
                gradient.addColorStop(0.5, "rgb(184,203,184)");
                gradient.addColorStop(1, "black"); //rgb(46,57,46)");
            }
            x = scaleOriginX + shift;
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = gradient;
            ctx.fillRect(x + thimbleX2 + 49, thimbleY3, (thimbleX3 - thimbleX2 -
                153), 2 * R);
            ctx.globalAlpha = 1;
            ctx.fillStyle = scaleColor;
            ctx.strokeStyle = scaleColor;
            x = scaleOriginX + shift;
            y = scaleOriginY;
            ctx.font = '10pt sans-serif';
            R = scaleOriginY - thimbleY1;
            let dy1 = 0,
                dy2 = 0;
            let dth = Math.PI / 2 / N;
            let divPos;
            let sinTh = 0
            let csrWithZE = getCircularScaleReading();
            drawLine(x, thimbleY1 - 1, x, thimbleY1 + 2 * R + 1);
            for (let i = 0; i < N; i++) {
                sinTh = Math.sin(i * dth);
                if (sinTh > 0.7) ctx.globalAlpha = 1 - 3 * (sinTh - 0.7)
                dy1 = R * sinTh;
                dy2 = dy1 * (R + 4) / R;
                y = scaleOriginY - dy1;
                divPos = mod(csrWithZE + i, circularScaleDivisions);
                ticklength = vernierMinorTickLengthPixels;
                if (divPos % 5 == 0) {
                    ticklength = vernierMajorTickLengthPixels;
                    dy2 = dy1 * (R + 8) / R;
                    if (i < N - 2) outString(x + thimbleX2 + 4, scaleOriginY -
                        dy2, divPos, 0, 1);
                }
                drawLine(x, y, x + ticklength, scaleOriginY - dy2);
                if (i == 0) continue;
                dy2 = dy1 * (R + 4) / R;
                y = scaleOriginY + dy1;
                divPos = mod(csrWithZE - i, circularScaleDivisions);
                ticklength = vernierMinorTickLengthPixels;
                if (divPos % 5 == 0) {
                    ticklength = vernierMajorTickLengthPixels;
                    dy2 = dy1 * (R + 8) / R;
                    if (i < N - 2) outString(x + thimbleX2 + 4, scaleOriginY +
                        dy2, divPos, 0, 1);
                }
                drawLine(x, y, x + ticklength, scaleOriginY + dy2);
            }
            ctx.restore();
            ctx.fillStyle = fgColor;
            ctx.font = '12pt sans-serif';
            if (objectTobeMeasured.state > 0) {
                let grd = ctx.createLinearGradient(objectTobeMeasured.x,
                    objectTobeMeasured.y, objectTobeMeasured.x +
                objectTobeMeasured.w, objectTobeMeasured.y);
                grd.addColorStop(0, "rgb(120,120,120)")
                grd.addColorStop(0.5, "rgb(220,230,210)")
                grd.addColorStop(1, "rgb(120,120,120)")
                ctx.fillStyle = grd;
                ctx.fillRect(objectTobeMeasured.x + 1, objectTobeMeasured.y,
                    objectTobeMeasured.w, objectTobeMeasured.h);
                ctx.strokeStyle = scaleColor;
                ctx.strokeRect(objectTobeMeasured.x + 1, objectTobeMeasured.y,
                    objectTobeMeasured.w, objectTobeMeasured.h);
                ctx.fillStyle = fgColor;
            }
            // Draw touch interaction feedback
            if (dragMode == 2) {
                let shift = (msr + csr / circularScaleDivisions) * msd_pixels;
                let feedbackX = scaleOriginX + shift + thimbleX2 + (thimbleX3 - thimbleX2) / 2;
                let feedbackY = scaleOriginY;
                let feedbackRadius = (scaleOriginY - thimbleY3) + 30;

                // Draw touch feedback circle
                ctx.save();
                ctx.strokeStyle = "rgba(100, 200, 255, 0.6)";
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.arc(feedbackX, feedbackY, feedbackRadius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();

                // Draw rotation direction arrows
                ctx.save();
                ctx.fillStyle = "rgba(100, 200, 255, 0.8)";
                ctx.font = "20px Arial";
                ctx.fillText("‚Üª", feedbackX - 40, feedbackY - feedbackRadius - 10);
                ctx.fillText("‚Ü∫", feedbackX + 30, feedbackY - feedbackRadius - 10);
                ctx.restore();
            }

            // Always show current reading in a prominent way
            ctx.save();
            ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
            ctx.fillRect(10, 10, 300, 60);
            ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
            ctx.strokeRect(10, 10, 300, 60);

            ctx.fillStyle = "white";
            ctx.font = "bold 16px Arial";
            ctx.fillText("Reading: " + formatValue(getCorrectedReading()), 20, 35);
            ctx.font = "12px Arial";
            ctx.fillText("MSR: " + getMainScaleReading() + " | CSR: " + getCircularScaleReading(), 20, 55);
            ctx.restore();

            if (displayInfo) drawInfo();
            ctx.resetTransform();
            // ctx.drawImage(imgSimphy,5,5,100,30);
        }
        function drawInfo() {
            //draw MSD Info and CSD Info
            ctx.lineWidth = 1.5;
            ctx.fillStyle = fgColor;
            ctx.strokeStyle = fgColor;
            //dra MSD Hint
            let x = scaleOriginX - msd_pixels * zeroError /
                circularScaleDivisions + getMainScaleReading() * msd_pixels;
            let y = scaleOriginY + 2 + minorTickLengthPixels;
            let arrowSize = 5;
            drawLineWithArrows(x, y, x, y + 50, arrowSize, arrowSize, true,
                false);
            outString(x, y + 53, getMainScaleReading() + "MSD = " + formatValue(
                getMainScaleReading() * msdValue), 1, 0);
            //Draw CSD Hint
            let gappixel = msd_pixels * (msr + csr / circularScaleDivisions);
            x = scaleOriginX + gappixel + thimbleX2;
            y = scaleOriginY;
            drawLineWithArrows(x, y, x + 40, y, arrowSize, arrowSize, true,
                false);
            outString(x + 47, y, getCircularScaleReading() + "CSD = " +
                formatValue(msdValue * getCircularScaleReading() /
                    circularScaleDivisions), 0, 1);
            //Draw SCrew gauge Reading
            x = spindleOriginX - 1;
            y = spindleOriginY - 20;
            drawLineWithArrows(x - 30, y, x, y, arrowSize, arrowSize, false,
                true);
            x = spindleOriginX + gappixel + 3;
            y = spindleOriginY - 20;
            drawLineWithArrows(x, y, x + 30, y, arrowSize, arrowSize, true,
                false);
            let mr = getMeasuredReading();
            let cr = getCorrectedReading();
            let ze = getZeroError();
            y = spindleOriginY - 42;
            x = spindleOriginX + gappixel / 2;
            if (ze == 0) {
                outString(x, y, formatValue(cr), 1, 1);
            } else if (ze > 0) {
                outString(x, y, formatValue(mr) + ' - ' + formatValue(ze) +
                    " = " + formatValue(cr), 1, 1);
            } else {
                outString(x, y, formatValue(mr) + ' + ' + formatValue(-ze) +
                    " = " + formatValue(cr), 1, 1);
            }
        }
        function getZeroError() {
            return (zeroError / circularScaleDivisions) * msdValue;
        }
        function formatValue(s) {
            return s.toFixed(precision) + unit;
        }
        function getMainScaleReading() {
            return Math.floor((msr * circularScaleDivisions + csr + zeroError) /
                circularScaleDivisions);
        }
        function getCircularScaleReading() {
            return mod(csr + zeroError, circularScaleDivisions);
        }
        function getMeasuredReading() {
            return getCorrectedReading() + getZeroError();
        }
        function getCorrectedReading() {
            return (msr + csr / circularScaleDivisions) * msdValue;
        }
        /**
         * returns +ve remainder whn a is divided by n
         * */
        function mod(a, n) {
            return ((a % n) + n) % n;
        }
        function drawLine(x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
        function drawLineWithArrows(x0, y0, x1, y1, aWidth, aLength, arrowStart,
            arrowEnd) {
            var dx = x1 - x0;
            var dy = y1 - y0;
            var angle = Math.atan2(dy, dx);
            var length = Math.sqrt(dx * dx + dy * dy);
            //
            ctx.save();
            ctx.translate(x0, y0);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(length, 0);
            if (arrowStart) {
                ctx.moveTo(aLength, -aWidth);
                ctx.lineTo(0, 0);
                ctx.lineTo(aLength, aWidth);
            }
            if (arrowEnd) {
                ctx.moveTo(length - aLength, -aWidth);
                ctx.lineTo(length, 0);
                ctx.lineTo(length - aLength, aWidth);
            }
            //
            ctx.stroke();
            ctx.restore();
        }
        function outString(x, y, s, x_align, y_align) {
            var fm = ctx.measureText(s);
            var h = 10; //fm.height not supported in browsers
            switch (y_align) {
                case 0:
                    y += h;
                    break;
                case 1:
                    y += h / 2;
                    break;
                case 2:
                    break;
            }
            switch (x_align) {
                case 0:
                    ctx.fillText(s, x + 3, y);
                    break;
                case 1:
                    ctx.fillText(s, x - fm.width / 2, y);
                    break;
                case 2:
                    ctx.fillText(s, x - fm.width / 2, y);
                    break;
            }
        }
        function myTouchMove(te) {
            te.preventDefault();
            var touch = te.touches[0];
            var mouseEvent = new MouseEvent("mousemove", {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }
        function myTouchStart(te) {
            te.preventDefault();
            var touch = te.touches[0];
            var mouseEvent = new MouseEvent("mousedown", {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }
        function myTouchEnd(te) {
            te.preventDefault();
            var touch = te.touches[0];
            var mouseEvent = new MouseEvent("mouseup", {
                clientX: -1,
                clientY: -1
            });
            canvas.dispatchEvent(mouseEvent);
        }
        function getMousePos(event) {
            //let rect = canvas.getBoundingClientRect();
            return [event.clientX, event.clientY];
        }
        var initialTouchAngle = 0;
        var initialCSR = 0;
        var thimbleCenterX = 0;
        var thimbleCenterY = 0;
        var lastAngle = 0;
        var rotationVelocity = 0;
        var lastRotationTime = 0;

        // Slider control variables
        var sliderValue = 500; // Center position
        var isSliderActive = false;

        function mousePressed(me) {
            let m = getMousePos(me);
            //convert mouse pos in world coordinates taking translation and scale in account
            let x = m[0] / scale - xOffset;
            let y = m[1] / scale - yOffset;
            console.log("mousepressed at " + x + "," + y)
            let shift = scaleOriginX + (msr + csr / circularScaleDivisions) *
                msd_pixels;

            // Enhanced thimble detection area for better touch interaction
            thimbleCenterX = shift + thimbleX2 + (thimbleX3 - thimbleX2) / 2;
            thimbleCenterY = scaleOriginY;
            let thimbleRadius = (scaleOriginY - thimbleY3) + 20; // Extended radius for easier touch
            let distanceFromCenter = Math.sqrt((x - thimbleCenterX) * (x - thimbleCenterX) +
                (y - thimbleCenterY) * (y - thimbleCenterY));

            if (distanceFromCenter < thimbleRadius &&
                x > shift + thimbleX2 - 20 && x < shift + thimbleX3 + 20 &&
                y > thimbleY3 - 20 && y < thimbleY3 + 2 * (scaleOriginY - thimbleY3) + 20) {
                dragMode = 2;
                // Store initial angle and CSR for rotational dragging
                initialTouchAngle = Math.atan2(y - thimbleCenterY, x - thimbleCenterX);
                lastAngle = initialTouchAngle;
                initialCSR = csr;
                rotationVelocity = 0;
                lastRotationTime = Date.now();
            } else if (objectTobeMeasured.state > 0 && x > objectTobeMeasured
                .x && x < objectTobeMeasured.x + objectTobeMeasured.w && y >
                objectTobeMeasured.y && y < objectTobeMeasured.y +
                objectTobeMeasured.h) {
                dragMode = 3;
                objectTobeMeasured.state = 1;
            } else {
                dragMode = 1;
            }
            paint();
            mx = m[0];
            my = m[1];
            me.preventDefault();
        }
        function mouseReleased(me) {
            if (dragMode == 3) { //move object
                if (Math.abs(objectTobeMeasured.x - spindleOriginX) < 200 &&
                    Math.abs(objectTobeMeasured.y - scaleOriginY +
                        objectTobeMeasured.h / 2) < objectTobeMeasured.h / 2 +
                    50) {
                    objectTobeMeasured.x = spindleOriginX;
                    objectTobeMeasured.y = scaleOriginY - objectTobeMeasured.h /
                        2;
                    objectTobeMeasured.state = 2;
                }
                update();
            } else if (dragMode == 2) {
                // Add momentum/inertia effect for smooth rotation
                if (Math.abs(rotationVelocity) > 0.1) {
                    animateRotationMomentum();
                }
            }
            dragMode = 0;
            paint(); // Refresh to remove touch feedback
        }

        function animateRotationMomentum() {
            if (Math.abs(rotationVelocity) < 0.05) return;

            let divisions = Math.round(rotationVelocity * 2);
            if (divisions != 0) {
                rotateVernier(divisions);
            }

            rotationVelocity *= 0.9; // Damping

            if (Math.abs(rotationVelocity) > 0.05) {
                setTimeout(animateRotationMomentum, 50);
            }
        }
        function mouseWheelMoved(me) {
            //console.log(e.wheelDelta);
            var scroll = me.wheelDelta > 0 ? 1 : -1;
            rotateVernier(scroll);
            me.preventDefault();
        }
        function mouseDragged(me) {
            if (dragMode == 0) return false;
            let m = getMousePos(me);
            let dx, dy;
            dx = (m[0] - mx) / scale;
            dy = (m[1] - my) / scale;
            mx = m[0];
            my = m[1];
            if (dragMode == 1) { //move scene
                xOffset += dx;
                yOffset += dy;
                paint();
            } else if (dragMode == 3) { //move object
                objectTobeMeasured.x += dx;
                objectTobeMeasured.y += dy;
                paint();
            } else if (dragMode == 2) { //rotate thimble
                let x = m[0] / scale - xOffset;
                let y = m[1] / scale - yOffset;

                // Calculate current angle from thimble center
                let currentAngle = Math.atan2(y - thimbleCenterY, x - thimbleCenterX);
                let angleDifference = currentAngle - lastAngle;

                // Normalize angle difference to -œÄ to œÄ
                while (angleDifference > Math.PI) angleDifference -= 2 * Math.PI;
                while (angleDifference < -Math.PI) angleDifference += 2 * Math.PI;

                // Calculate rotation velocity for momentum
                let currentTime = Date.now();
                if (currentTime - lastRotationTime > 0) {
                    rotationVelocity = angleDifference / (currentTime - lastRotationTime) * 1000;
                }
                lastRotationTime = currentTime;
                lastAngle = currentAngle;

                // Convert angle to divisions (more sensitive rotation)
                let totalAngleDiff = currentAngle - initialTouchAngle;
                while (totalAngleDiff > Math.PI) totalAngleDiff -= 2 * Math.PI;
                while (totalAngleDiff < -Math.PI) totalAngleDiff += 2 * Math.PI;

                let divisionChange = Math.round(totalAngleDiff * circularScaleDivisions / (2 * Math.PI) * 2);
                let newCSR = initialCSR + divisionChange;

                // Apply the rotation with bounds checking
                let targetCSR = newCSR;
                let targetMSR = msr;

                // Handle overflow/underflow
                while (targetCSR < 0) {
                    targetCSR += circularScaleDivisions;
                    targetMSR -= 1;
                }
                while (targetCSR >= circularScaleDivisions) {
                    targetCSR -= circularScaleDivisions;
                    targetMSR += 1;
                }

                // Check bounds
                if (targetMSR >= 0 && targetMSR <= mainScaleDivisions) {
                    let oldCSR = csr;
                    let oldMSR = msr;
                    csr = targetCSR;
                    msr = targetMSR;

                    // Play tick sound for significant changes
                    if (Math.abs(csr - oldCSR) > 1 || msr != oldMSR) {
                        playTickSound();
                    }

                    update();
                } else {
                    // Reset to bounds
                    if (targetMSR < 0) {
                        msr = 0;
                        csr = 0;
                    } else if (targetMSR > mainScaleDivisions) {
                        msr = mainScaleDivisions;
                        csr = 0;
                    }
                    paint();
                }
            }
            me.preventDefault();
        }
        function onKeyEvent(e) {
            if (e.keyCode == 37 || e.keyCode == 38) {
                rotateVernier(-1);
            } else if (e.keyCode == 39 || e.keyCode == 40) {
                rotateVernier(1);
            } else if (e.keyCode == 33) { //page up
                scale *= 1.05;
                update();
            } else if (e.keyCode == 34) { //page down
                scale *= 0.96195;
                update();
            } else {
                return false;
            }
            e.preventDefault();
        }

        // Slider control functions
        function setupSliderControls() {
            const slider = document.getElementById('rotationSlider');
            const rotateLeftBtn = document.getElementById('rotateLeft');
            const rotateRightBtn = document.getElementById('rotateRight');
            const mainReading = document.getElementById('mainReading');
            const subReading = document.getElementById('subReading');

            // Initialize slider position based on current readings
            updateSliderFromReadings();

            // Slider input event
            slider.addEventListener('input', function (e) {
                isSliderActive = true;
                sliderValue = parseInt(e.target.value);
                updateReadingsFromSlider();
                updateReadingDisplay();
            });

            // Slider change event (when user releases)
            slider.addEventListener('change', function (e) {
                isSliderActive = false;
                playTickSound();
            });

            // Left rotation button
            rotateLeftBtn.addEventListener('click', function () {
                rotateVernier(-1);
                updateSliderFromReadings();
                updateReadingDisplay();
            });

            // Right rotation button  
            rotateRightBtn.addEventListener('click', function () {
                rotateVernier(1);
                updateSliderFromReadings();
                updateReadingDisplay();
            });

            // Touch and hold for continuous rotation
            let rotationInterval;

            function startContinuousRotation(direction) {
                rotationInterval = setInterval(() => {
                    rotateVernier(direction);
                    updateSliderFromReadings();
                    updateReadingDisplay();
                }, 100);
            }

            function stopContinuousRotation() {
                if (rotationInterval) {
                    clearInterval(rotationInterval);
                    rotationInterval = null;
                }
            }

            // Touch events for continuous rotation
            rotateLeftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startContinuousRotation(-1);
            });

            rotateRightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startContinuousRotation(1);
            });

            rotateLeftBtn.addEventListener('touchend', stopContinuousRotation);
            rotateRightBtn.addEventListener('touchend', stopContinuousRotation);

            // Mouse events for continuous rotation
            rotateLeftBtn.addEventListener('mousedown', () => startContinuousRotation(-1));
            rotateRightBtn.addEventListener('mousedown', () => startContinuousRotation(1));

            document.addEventListener('mouseup', stopContinuousRotation);
            document.addEventListener('touchend', stopContinuousRotation);

            // Initial display update
            updateReadingDisplay();
        }

        function updateSliderFromReadings() {
            if (isSliderActive) return; // Don't update if user is actively using slider

            const totalReading = msr + (csr / circularScaleDivisions);
            const maxReading = mainScaleDivisions;
            const sliderPosition = (totalReading / maxReading) * 1000;

            document.getElementById('rotationSlider').value = Math.max(0, Math.min(1000, sliderPosition));
        }

        function updateReadingsFromSlider() {
            const sliderPosition = sliderValue / 1000; // 0 to 1
            const totalDivisions = sliderPosition * mainScaleDivisions;

            const newMSR = Math.floor(totalDivisions);
            const newCSR = Math.round((totalDivisions - newMSR) * circularScaleDivisions);

            // Apply bounds checking
            if (newMSR >= 0 && newMSR <= mainScaleDivisions) {
                msr = newMSR;
                csr = newCSR >= circularScaleDivisions ? 0 : newCSR;

                if (csr >= circularScaleDivisions) {
                    msr = Math.min(msr + 1, mainScaleDivisions);
                    csr = 0;
                }

                update();
            }
        }

        function updateReadingDisplay() {
            const mainReading = document.getElementById('mainReading');
            const subReading = document.getElementById('subReading');

            if (mainReading && subReading) {
                mainReading.textContent = formatValue(getCorrectedReading());
                subReading.textContent = `MSR: ${getMainScaleReading()} | CSR: ${getCircularScaleReading()}`;
            }
        }

        // Override the existing update function to also update the slider display
        const originalUpdate = update;
        update = function () {
            originalUpdate();
            updateSliderFromReadings();
            updateReadingDisplay();
        };
    </script>
</body>

</html>