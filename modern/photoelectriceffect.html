<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photoelectric Effect - Light Above Collector</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a2a, #1a1a4a);
            color: white;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            max-width: 1400px;
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin-top: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 25px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(90deg, #ff6b35, #f7931e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .simulation-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .canvas-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }
        
        #simulationCanvas {
            background: #0a0a2a;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-title {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .value-display {
            font-weight: bold;
            color: #ff6b35;
        }
        
        input[type="range"] {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: #4a4a4a;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #ff6b35;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        select {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            background: #4a4a4a;
            color: white;
            border: none;
            outline: none;
            font-size: 1rem;
        }
        
        .button-group {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
        }
        
        button {
            padding: 14px 30px;
            border: none;
            border-radius: 50px;
            background: linear-gradient(to right, #ff6b35, #f7931e);
            color: white;
            font-weight: bold;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin-top: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .info-title {
            font-size: 1.4rem;
            margin-bottom: 20px;
            text-align: center;
            color: #ff6b35;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .info-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .info-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 8px;
        }
        
        .info-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #ff6b35;
        }
        
        .instructions {
            margin-top: 25px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            font-size: 1rem;
            line-height: 1.6;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .instructions h3 {
            color: #ff6b35;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        
        .status-indicator {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 12px 18px;
            display: flex;
            align-items: center;
            gap: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .status-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #4CAF50;
        }
        
        .status-dot.paused {
            background: #FF9800;
        }
        
        .status-text {
            font-size: 1rem;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .button-group {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Photoelectric Effect - Light Above Collector</h1>
            <p class="subtitle">Electrons emit from emitter when light energy exceeds work function, even with zero voltage</p>
        </header>
        
        <div class="simulation-area">
            <div class="canvas-container">
                <canvas id="simulationCanvas" width="1200" height="600"></canvas>
                <div class="status-indicator">
                    <div class="status-dot" id="statusDot"></div>
                    <div class="status-text" id="statusText">Ready</div>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <div class="control-title">
                        <span>Light Frequency</span>
                        <span id="frequencyValue" class="value-display">600 THz</span>
                    </div>
                    <input type="range" id="frequencySlider" min="400" max="1000" value="600" step="10">
                    <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.9rem;">
                        <span>Infrared</span>
                        <span>Visible</span>
                        <span>UV</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-title">
                        <span>Light Intensity</span>
                        <span id="intensityValue" class="value-display">50%</span>
                    </div>
                    <input type="range" id="intensitySlider" min="0" max="100" value="50" step="5">
                </div>
                
                <div class="control-group">
                    <div class="control-title">
                        <span>Metal Work Function</span>
                        <span id="workFunctionValue" class="value-display">2.0 eV</span>
                    </div>
                    <select id="metalSelect">
                        <option value="1.5">Cesium (1.5 eV)</option>
                        <option value="2.0">Potassium (2.0 eV)</option>
                        <option value="2.3">Sodium (2.3 eV)</option>
                        <option value="4.1">Copper (4.1 eV)</option>
                        <option value="4.7">Iron (4.7 eV)</option>
                        <option value="5.1">Platinum (5.1 eV)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <div class="control-title">
                        <span>Applied Voltage</span>
                        <span id="voltageValue" class="value-display">0 V</span>
                    </div>
                    <input type="range" id="voltageSlider" min="-5" max="5" value="0" step="0.1">
                    <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.9rem;">
                        <span>Retarding</span>
                        <span>Zero</span>
                        <span>Accelerating</span>
                    </div>
                </div>
            </div>
            
            <div class="button-group">
                <button id="startButton">Start Simulation</button>
                <button id="resetButton">Reset Simulation</button>
                <button id="photonButton">Emit Single Photon</button>
            </div>
            
            <div class="info-panel">
                <h3 class="info-title">Quantum Physics Information</h3>
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">Photon Energy</div>
                        <div id="photonEnergyValue" class="info-value">2.48 eV</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Electron Kinetic Energy</div>
                        <div id="kineticEnergyValue" class="info-value">0.48 eV</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Current Flow</div>
                        <div id="currentValue" class="info-value">0.0 μA</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Electrons Emitted</div>
                        <div id="electronsValue" class="info-value">0</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Stopping Potential</div>
                        <div id="stoppingPotentialValue" class="info-value">0.48 V</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Threshold Frequency</div>
                        <div id="thresholdValue" class="info-value">483 THz</div>
                    </div>
                </div>
            </div>
            
            <div class="instructions">
                <h3>Key Observations:</h3>
                <p>• <strong>Electrons emit immediately</strong> when light energy > work function, even with zero voltage</p>
                <p>• <strong>No time delay</strong> - emission is instantaneous (proves particle nature of light)</p>
                <p>• <strong>Frequency threshold</strong> - no emission below certain frequency regardless of intensity</p>
                <p>• <strong>Kinetic energy depends on frequency</strong>, not intensity</p>
                <p>• <strong>Current depends on intensity</strong> - more photons = more electrons</p>
            </div>
        </div>
    </div>

    <script>
        // Get DOM elements
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const frequencySlider = document.getElementById('frequencySlider');
        const intensitySlider = document.getElementById('intensitySlider');
        const metalSelect = document.getElementById('metalSelect');
        const voltageSlider = document.getElementById('voltageSlider');
        const frequencyValue = document.getElementById('frequencyValue');
        const intensityValue = document.getElementById('intensityValue');
        const workFunctionValue = document.getElementById('workFunctionValue');
        const voltageValue = document.getElementById('voltageValue');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const photonButton = document.getElementById('photonButton');
        
        // Info panel elements
        const photonEnergyValue = document.getElementById('photonEnergyValue');
        const kineticEnergyValue = document.getElementById('kineticEnergyValue');
        const currentValue = document.getElementById('currentValue');
        const electronsValue = document.getElementById('electronsValue');
        const stoppingPotentialValue = document.getElementById('stoppingPotentialValue');
        const thresholdValue = document.getElementById('thresholdValue');
        
        // Status indicator
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');

        // Simulation parameters
        let frequency = parseInt(frequencySlider.value); // THz
        let intensity = parseInt(intensitySlider.value); // %
        let workFunction = parseFloat(metalSelect.value); // eV
        let voltage = parseFloat(voltageSlider.value); // V
        let isRunning = false;
        let animationId = null;
        let timeElapsed = 0;
        
        // Physical constants
        const PLANCK_CONSTANT = 4.135667662e-15; // eV·s
        const ELECTRON_CHARGE = 1.602e-19; // C
        
        // Glass tube dimensions
        const glassTube = {
            x: 150,
            y: 150,
            width: 800,
            height: 300,
            thickness: 10
        };
        
        // Simulation elements
        const elements = {
            emitter: {
                x: glassTube.x + 200,
                y: glassTube.y + glassTube.height / 2 - 50,
                width: 80,
                height: 100,
                electrons: [],
                color: '#8B4513'
            },
            collector: {
                x: glassTube.x + glassTube.width - 280,
                y: glassTube.y + glassTube.height / 2 - 50,
                width: 80,
                height: 100,
                collectedElectrons: [],
                color: '#4682B4'
            },
            photons: [],
            freeElectrons: [], // Electrons that have been emitted
            lightSource: {
                x: glassTube.x + glassTube.width / 2, // Above collector
                y: glassTube.y - 80,
                radius: 30
            }
        };
        
        // Initialize electrons in emitter
        function initializeElectrons() {
            elements.emitter.electrons = [];
            elements.freeElectrons = [];
            elements.collector.collectedElectrons = [];
            
            // Create bound electrons in the emitter metal
            for (let i = 0; i < 20; i++) {
                elements.emitter.electrons.push({
                    x: elements.emitter.x + 10 + Math.random() * 60,
                    y: elements.emitter.y + 10 + Math.random() * 80,
                    radius: 4,
                    state: 'bound',
                    vibration: Math.random() * Math.PI * 2
                });
            }
        }
        
        // Update display values when controls change
        frequencySlider.addEventListener('input', function() {
            frequency = parseInt(this.value);
            frequencyValue.textContent = frequency + ' THz';
            updateCalculations();
        });
        
        intensitySlider.addEventListener('input', function() {
            intensity = parseInt(this.value);
            intensityValue.textContent = intensity + '%';
        });
        
        metalSelect.addEventListener('change', function() {
            workFunction = parseFloat(this.value);
            workFunctionValue.textContent = workFunction.toFixed(1) + ' eV';
            updateCalculations();
            // Change emitter color based on metal
            const metalColors = {
                '1.5': '#FFD700', // Cesium - Gold
                '2.0': '#B8860B', // Potassium - DarkGoldenrod
                '2.3': '#FFA500', // Sodium - Orange
                '4.1': '#8B4513', // Copper - SaddleBrown
                '4.7': '#A9A9A9', // Iron - DarkGray
                '5.1': '#E5E4E2'  // Platinum - Platinum
            };
            elements.emitter.color = metalColors[workFunction] || '#8B4513';
        });
        
        voltageSlider.addEventListener('input', function() {
            voltage = parseFloat(this.value);
            voltageValue.textContent = voltage.toFixed(1) + ' V';
        });
        
        // Button event listeners
        startButton.addEventListener('click', function() {
            if (!isRunning) {
                isRunning = true;
                startButton.textContent = 'Pause Simulation';
                statusDot.classList.remove('paused');
                statusText.textContent = 'Running';
                runSimulation();
            } else {
                isRunning = false;
                startButton.textContent = 'Resume Simulation';
                statusDot.classList.add('paused');
                statusText.textContent = 'Paused';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            }
        });
        
        resetButton.addEventListener('click', function() {
            resetSimulation();
        });
        
        photonButton.addEventListener('click', function() {
            emitSinglePhoton();
        });
        
        // Update physics calculations
        function updateCalculations() {
            // Calculate photon energy
            const photonEnergy = (PLANCK_CONSTANT * frequency * 1e12).toFixed(2);
            
            // Calculate kinetic energy of ejected electrons
            const kineticEnergy = Math.max(0, photonEnergy - workFunction).toFixed(2);
            
            // Calculate threshold frequency
            const thresholdFrequency = (workFunction / PLANCK_CONSTANT / 1e12).toFixed(0);
            
            // Update display values
            photonEnergyValue.textContent = photonEnergy + ' eV';
            kineticEnergyValue.textContent = kineticEnergy + ' eV';
            stoppingPotentialValue.textContent = kineticEnergy + ' V';
            thresholdValue.textContent = thresholdFrequency + ' THz';
        }
        
        // Reset simulation to initial state
        function resetSimulation() {
            isRunning = false;
            startButton.textContent = 'Start Simulation';
            statusDot.classList.add('paused');
            statusText.textContent = 'Ready';
            
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Reset elements
            elements.photons = [];
            timeElapsed = 0;
            
            // Reinitialize electrons
            initializeElectrons();
            
            // Update calculations
            updateCalculations();
            
            drawScene();
            updateInfoPanel();
        }
        
        // Run the simulation
        function runSimulation() {
            if (!isRunning) return;
            
            // Update physics
            updatePhysics();
            
            // Draw the scene
            drawScene();
            
            // Update information panel
            updateInfoPanel();
            
            // Continue animation
            animationId = requestAnimationFrame(runSimulation);
        }
        
        // Emit a single photon
        function emitSinglePhoton() {
            const photonEnergy = PLANCK_CONSTANT * frequency * 1e12;
            
            if (photonEnergy > workFunction) {
                elements.photons.push({
                    x: elements.lightSource.x,
                    y: elements.lightSource.y,
                    targetX: elements.emitter.x + Math.random() * elements.emitter.width,
                    targetY: elements.emitter.y + elements.emitter.height,
                    speed: 6,
                    energy: photonEnergy,
                    active: true,
                    progress: 0
                });
            }
        }
        
        // Update physics calculations
        function updatePhysics() {
            const timeStep = 0.016;
            
            // Emit photons based on intensity
            if (isRunning) {
                const photonEnergy = PLANCK_CONSTANT * frequency * 1e12;
                
                if (photonEnergy > workFunction) {
                    const emissionRate = intensity / 100 * 2;
                    
                    for (let i = 0; i < emissionRate; i++) {
                        if (Math.random() < 0.4) {
                            elements.photons.push({
                                x: elements.lightSource.x,
                                y: elements.lightSource.y,
                                targetX: elements.emitter.x + Math.random() * elements.emitter.width,
                                targetY: elements.emitter.y + elements.emitter.height,
                                speed: 6,
                                energy: photonEnergy,
                                active: true,
                                progress: 0
                            });
                        }
                    }
                }
            }
            
            // Update photons
            for (let i = elements.photons.length - 1; i >= 0; i--) {
                const photon = elements.photons[i];
                
                if (photon.active) {
                    // Move photon toward target using linear interpolation
                    photon.progress += photon.speed * 0.01;
                    photon.x = elements.lightSource.x + (photon.targetX - elements.lightSource.x) * photon.progress;
                    photon.y = elements.lightSource.y + (photon.targetY - elements.lightSource.y) * photon.progress;
                    
                    if (photon.progress >= 1) {
                        // Photon reached target - emit electron immediately
                        photon.active = false;
                        emitElectron(photon);
                    }
                } else {
                    // Remove inactive photons
                    elements.photons.splice(i, 1);
                }
            }
            
            // Update free electrons
            for (let i = elements.freeElectrons.length - 1; i >= 0; i--) {
                const electron = elements.freeElectrons[i];
                
                // Update electron position based on voltage
                if (voltage >= 0) {
                    // Accelerating or zero voltage - move toward collector
                    electron.x += electron.velocity.x;
                } else {
                    // Retarding voltage - slower movement or bounce back
                    electron.x += electron.velocity.x * 0.5;
                }
                
                // Add some random vertical movement
                electron.y += (Math.random() - 0.5) * 0.5;
                
                // Add to trail
                electron.trail.push({ x: electron.x, y: electron.y });
                if (electron.trail.length > 10) {
                    electron.trail.shift();
                }
                
                // Check if electron reaches collector
                if (electron.x >= elements.collector.x && 
                    electron.x <= elements.collector.x + elements.collector.width &&
                    electron.y >= elements.collector.y && 
                    electron.y <= elements.collector.y + elements.collector.height) {
                    
                    if (voltage >= 0 || electron.kineticEnergy > Math.abs(voltage)) {
                        // Electron collected
                        electron.state = 'collected';
                        elements.collector.collectedElectrons.push(electron);
                        elements.freeElectrons.splice(i, 1);
                    }
                }
                
                // Check if electron goes out of bounds
                if (electron.x > glassTube.x + glassTube.width - glassTube.thickness || 
                    electron.y < glassTube.y + glassTube.thickness || 
                    electron.y > glassTube.y + glassTube.height - glassTube.thickness) {
                    
                    elements.freeElectrons.splice(i, 1);
                }
            }
            
            // Update bound electrons vibration
            for (let electron of elements.emitter.electrons) {
                if (electron.state === 'bound') {
                    electron.vibration += 0.15;
                }
            }
            
            // Update time
            timeElapsed += timeStep;
        }
        
        // Emit an electron when photon hits with sufficient energy
        function emitElectron(photon) {
            const kineticEnergy = photon.energy - workFunction;
            
            if (kineticEnergy > 0 && elements.emitter.electrons.length > 0) {
                // Remove one bound electron
                const boundIndex = Math.floor(Math.random() * elements.emitter.electrons.length);
                const boundElectron = elements.emitter.electrons[boundIndex];
                
                // Create free electron at emitter surface
                const freeElectron = {
                    x: boundElectron.x,
                    y: boundElectron.y,
                    radius: 5,
                    kineticEnergy: kineticEnergy,
                    velocity: {
                        x: (1 + Math.random() * 0.5) * (kineticEnergy * 0.1), // Speed based on kinetic energy
                        y: (Math.random() - 0.5) * 0.5
                    },
                    state: 'free',
                    trail: []
                };
                
                elements.freeElectrons.push(freeElectron);
                elements.emitter.electrons.splice(boundIndex, 1);
                
                // Add new bound electron after a delay
                setTimeout(() => {
                    if (!isRunning) return;
                    elements.emitter.electrons.push({
                        x: elements.emitter.x + 10 + Math.random() * 60,
                        y: elements.emitter.y + 10 + Math.random() * 80,
                        radius: 4,
                        state: 'bound',
                        vibration: Math.random() * Math.PI * 2
                    });
                }, 500);
            }
        }
        
        // Draw the scene
        function drawScene() {
            // Clear canvas with dark background
            ctx.fillStyle = '#0a0a2a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw background grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw glass tube
            drawGlassTube();
            
            // Draw light source above collector
            drawLightSource();
            
            // Draw photons
            drawPhotons();
            
            // Draw emitter and collector plates
            drawMetalPlates();
            
            // Draw electrons
            drawElectrons();
            
            // Draw labels and information
            drawLabels();
        }
        
        // Draw glass vacuum tube
        function drawGlassTube() {
            // Glass tube main body
            ctx.fillStyle = 'rgba(200, 220, 255, 0.1)';
            ctx.strokeStyle = 'rgba(200, 220, 255, 0.3)';
            ctx.lineWidth = glassTube.thickness;
            ctx.strokeRect(
                glassTube.x, glassTube.y,
                glassTube.width, glassTube.height
            );
            
            // Glass reflections
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.strokeRect(
                glassTube.x + 10, glassTube.y + 10,
                glassTube.width - 20, glassTube.height - 20
            );
        }
        
        // Draw light source above collector
        function drawLightSource() {
            // Light source bulb
            const lightGradient = ctx.createRadialGradient(
                elements.lightSource.x, elements.lightSource.y, 0,
                elements.lightSource.x, elements.lightSource.y, elements.lightSource.radius
            );
            
            // Color based on frequency
            let lightColor;
            if (frequency < 480) lightColor = '#FF0000';
            else if (frequency < 510) lightColor = '#FF4500';
            else if (frequency < 540) lightColor = '#FFA500';
            else if (frequency < 570) lightColor = '#FFFF00';
            else if (frequency < 600) lightColor = '#9ACD32';
            else if (frequency < 630) lightColor = '#00FF00';
            else if (frequency < 660) lightColor = '#00FFFF';
            else if (frequency < 690) lightColor = '#0000FF';
            else if (frequency < 720) lightColor = '#8A2BE2';
            else lightColor = '#9400D3';
            
            lightGradient.addColorStop(0, lightColor);
            lightGradient.addColorStop(1, lightColor + '80');
            
            ctx.fillStyle = lightGradient;
            ctx.beginPath();
            ctx.arc(elements.lightSource.x, elements.lightSource.y, elements.lightSource.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Light source glow
            ctx.fillStyle = lightColor + '40';
            ctx.beginPath();
            ctx.arc(elements.lightSource.x, elements.lightSource.y, elements.lightSource.radius * 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Light beam to emitter
            if (isRunning || elements.photons.length > 0) {
                const beamGradient = ctx.createLinearGradient(
                    elements.lightSource.x, elements.lightSource.y,
                    elements.emitter.x + elements.emitter.width/2, elements.emitter.y + elements.emitter.height
                );
                beamGradient.addColorStop(0, lightColor + '80');
                beamGradient.addColorStop(1, lightColor + '00');
                
                ctx.fillStyle = beamGradient;
                ctx.beginPath();
                ctx.moveTo(elements.lightSource.x - 20, elements.lightSource.y);
                ctx.lineTo(elements.lightSource.x + 20, elements.lightSource.y);
                ctx.lineTo(elements.emitter.x + elements.emitter.width/2 + 40, elements.emitter.y + elements.emitter.height);
                ctx.lineTo(elements.emitter.x + elements.emitter.width/2 - 40, elements.emitter.y + elements.emitter.height);
                ctx.closePath();
                ctx.fill();
            }
            
            // Light source label
            ctx.fillStyle = 'white';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('LIGHT SOURCE', elements.lightSource.x, elements.lightSource.y - 50);
        }
        
        // Draw photons as wave packets moving from light source to emitter
        function drawPhotons() {
            for (const photon of elements.photons) {
                if (photon.active) {
                    // Photon color based on frequency
                    let photonColor;
                    if (frequency < 480) photonColor = '#FF0000';
                    else if (frequency < 510) photonColor = '#FF4500';
                    else if (frequency < 540) photonColor = '#FFA500';
                    else if (frequency < 570) photonColor = '#FFFF00';
                    else if (frequency < 600) photonColor = '#9ACD32';
                    else if (frequency < 630) photonColor = '#00FF00';
                    else if (frequency < 660) photonColor = '#00FFFF';
                    else if (frequency < 690) photonColor = '#0000FF';
                    else if (frequency < 720) photonColor = '#8A2BE2';
                    else photonColor = '#9400D3';
                    
                    // Draw photon as a wave packet
                    ctx.strokeStyle = photonColor;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    const waveCount = 3;
                    const waveLength = 10;
                    const amplitude = 4;
                    
                    for (let i = 0; i < waveCount; i++) {
                        const startX = photon.x - i * waveLength;
                        const startY = photon.y;
                        
                        if (i === 0) {
                            ctx.moveTo(startX, startY);
                        }
                        
                        ctx.bezierCurveTo(
                            startX - waveLength/2, startY - amplitude,
                            startX + waveLength/2, startY - amplitude,
                            startX + waveLength, startY
                        );
                    }
                    
                    ctx.stroke();
                }
            }
        }
        
        // Draw emitter and collector plates
        function drawMetalPlates() {
            // Emitter plate
            const emitterGradient = ctx.createLinearGradient(
                elements.emitter.x, elements.emitter.y,
                elements.emitter.x, elements.emitter.y + elements.emitter.height
            );
            emitterGradient.addColorStop(0, elements.emitter.color);
            emitterGradient.addColorStop(1, '#5D4037');
            
            ctx.fillStyle = emitterGradient;
            ctx.fillRect(
                elements.emitter.x, elements.emitter.y,
                elements.emitter.width, elements.emitter.height
            );
            
            // Emitter surface texture
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i < 4; i++) {
                ctx.fillRect(
                    elements.emitter.x,
                    elements.emitter.y + i * 25,
                    elements.emitter.width, 2
                );
            }
            
            // Collector plate
            const collectorGradient = ctx.createLinearGradient(
                elements.collector.x, elements.collector.y,
                elements.collector.x, elements.collector.y + elements.collector.height
            );
            collectorGradient.addColorStop(0, elements.collector.color);
            collectorGradient.addColorStop(1, '#2F4F4F');
            
            ctx.fillStyle = collectorGradient;
            ctx.fillRect(
                elements.collector.x, elements.collector.y,
                elements.collector.width, elements.collector.height
            );
            
            // Collector surface texture
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i < 4; i++) {
                ctx.fillRect(
                    elements.collector.x,
                    elements.collector.y + i * 25,
                    elements.collector.width, 2
                );
            }
            
            // Plate labels
            ctx.fillStyle = 'white';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('EMITTER', elements.emitter.x + elements.emitter.width / 2, elements.emitter.y - 20);
            ctx.fillText('COLLECTOR', elements.collector.x + elements.collector.width / 2, elements.collector.y - 20);
        }
        
        // Draw electrons
        function drawElectrons() {
            // Draw bound electrons in emitter (vibrating)
            for (const electron of elements.emitter.electrons) {
                if (electron.state === 'bound') {
                    const vibX = Math.sin(electron.vibration) * 1.5;
                    const vibY = Math.cos(electron.vibration * 1.3) * 1.5;
                    
                    ctx.fillStyle = '#FF6B6B';
                    ctx.beginPath();
                    ctx.arc(
                        electron.x + vibX,
                        electron.y + vibY,
                        electron.radius, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }
            
            // Draw free electrons (emitted)
            for (const electron of elements.freeElectrons) {
                // Draw trail
                if (electron.trail.length > 1) {
                    ctx.strokeStyle = '#4FC3F7';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(electron.trail[0].x, electron.trail[0].y);
                    for (let i = 1; i < electron.trail.length; i++) {
                        ctx.lineTo(electron.trail[i].x, electron.trail[i].y);
                    }
                    ctx.stroke();
                }
                
                // Draw electron
                const electronGradient = ctx.createRadialGradient(
                    electron.x, electron.y, 0,
                    electron.x, electron.y, electron.radius
                );
                electronGradient.addColorStop(0, '#4FC3F7');
                electronGradient.addColorStop(1, '#01579B');
                
                ctx.fillStyle = electronGradient;
                ctx.beginPath();
                ctx.arc(electron.x, electron.y, electron.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw energy indicator for some electrons
                if (Math.random() < 0.1) {
                    ctx.fillStyle = '#4FC3F7';
                    ctx.font = '10px Arial';
                    ctx.fillText(electron.kineticEnergy.toFixed(1) + ' eV', electron.x - 15, electron.y - 8);
                }
            }
            
            // Draw collected electrons
            for (const electron of elements.collector.collectedElectrons) {
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(electron.x, electron.y, electron.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw labels and information
        function drawLabels() {
            ctx.fillStyle = 'white';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PHOTOELECTRIC EFFECT - INSTANT ELECTRON EMISSION', canvas.width / 2, 30);
            
            // Voltage indicator
            ctx.fillStyle = voltage >= 0 ? '#4CAF50' : '#F44336';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`Applied Voltage: ${voltage.toFixed(1)} V`, canvas.width / 2, elements.emitter.y - 50);
            
            // Key observation
            const photonEnergy = PLANCK_CONSTANT * frequency * 1e12;
            if (photonEnergy > workFunction) {
                ctx.fillStyle = '#4CAF50';
                ctx.font = 'italic 14px Arial';
                ctx.fillText('✓ Electrons emitting instantly (Energy > Work Function)', canvas.width / 2, glassTube.y + glassTube.height + 30);
            } else {
                ctx.fillStyle = '#F44336';
                ctx.font = 'italic 14px Arial';
                ctx.fillText('✗ No electron emission (Energy < Work Function)', canvas.width / 2, glassTube.y + glassTube.height + 30);
            }
        }
        
        // Update information panel
        function updateInfoPanel() {
            // Calculate current (simplified)
            const current = (elements.collector.collectedElectrons.length * ELECTRON_CHARGE * 1e6).toFixed(2);
            
            // Count emitted electrons
            const emittedElectrons = elements.freeElectrons.length + elements.collector.collectedElectrons.length;
            
            // Update display values
            currentValue.textContent = current + ' μA';
            electronsValue.textContent = emittedElectrons;
        }
        
        // Initialize the simulation
        initializeElectrons();
        updateCalculations();
        resetSimulation();
    </script>
</body>
</html>