<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rutherford — fixed distribution (10 particles)</title>
<style>
  html,body { height:100%; margin:0; background:#000; font-family:Segoe UI,Arial; color:#fff; }
  #ui { position:fixed; top:12px; left:12px; z-index:10; background:rgba(0,0,0,0.5); padding:10px 12px; border-radius:8px; }
  #ui button { margin-left:8px; padding:8px 12px; background:#ffcc00; border:0; border-radius:6px; cursor:pointer; font-weight:600; }
  #c { display:block; width:100vw; height:100vh; }
  #stats { margin-top:6px; color:#cfefff; font-size:13px; }
  #controls { position:fixed; top:12px; right:12px; z-index:10; }
  #controls button { padding:8px 12px; margin-left:8px; border-radius:6px; border:0; cursor:pointer; background:#18a0ff; color:#000; font-weight:700; }
</style>
</head>
<body>
  <div id="ui">
    <strong>Rutherford α-scattering</strong>
    <div id="stats">Total: <span id="tot">0</span> |
      Straight: <span id="st">0</span> |
      Deflected: <span id="df">0</span> |
      Bounced: <span id="bn">0</span>
    </div>
  </div>

  <div id="controls">
    <button id="start">Start</button>
    <button id="reset">Reset</button>
  </div>

  <canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  function fit() { canvas.width = innerWidth; canvas.height = innerHeight; }
  fit(); window.addEventListener('resize', () => { fit(); drawBackground(); });

  // UI
  const totEl = document.getElementById('tot');
  const stEl  = document.getElementById('st');
  const dfEl  = document.getElementById('df');
  const bnEl  = document.getElementById('bn');
  const startBtn = document.getElementById('start');
  const resetBtn = document.getElementById('reset');

  // Simulation params
  const N = 10;                       // total particles
  const beamX = 80;                   // emission x
  const foilX = () => Math.round(canvas.width * 0.65);
  const detectorX = () => Math.round(canvas.width * 0.92);
  const speed = 4.8;
  const foilThickness = 6;

  // desired distribution: 6 deflect, 2 straight, 2 bounce
  const distribution = { deflect:6, straight:2, bounce:2 };

  let particles = [];
  let nuclei = [];
  let running = false;
  let counts = { total:0, straight:0, deflected:0, bounced:0 };

  function updateCountsUI() {
    totEl.textContent = counts.total;
    stEl.textContent  = counts.straight;
    dfEl.textContent  = counts.deflected;
    bnEl.textContent  = counts.bounced;
  }

  // initialize particles: evenly vertical, all start same time
  function initParticles() {
    particles = [];
    const topY = canvas.height * 0.25;
    const bottomY = canvas.height * 0.75;

    // create array with exact kinds, shuffled
    const kinds = [];
    for (let i=0;i<distribution.deflect;i++) kinds.push('deflect');
    for (let i=0;i<distribution.straight;i++) kinds.push('straight');
    for (let i=0;i<distribution.bounce;i++) kinds.push('bounce');
    // shuffle
    for (let i = kinds.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random()*(i+1));
      [kinds[i], kinds[j]] = [kinds[j], kinds[i]];
    }

    for (let i=0;i<N;i++) {
      const y = topY + (i/(N-1))*(bottomY-topY);
      particles.push({
        x: beamX,
        y,
        vx: speed,
        vy: 0,
        r: 5,
        kind: kinds[i],
        hit: false,
        color: '#ffd86b'
      });
    }

    // create nuclei in foil region for visual effect (not necessary for deterministic outcome)
    buildNuclei();
    counts = { total:0, straight:0, deflected:0, bounced:0 };
    updateCountsUI();
  }

  function buildNuclei() {
    nuclei = [];
    if (particles.length === 0) return;
    const topY = Math.min(...particles.map(p=>p.y)) - 6;
    const bottomY = Math.max(...particles.map(p=>p.y)) + 6;
    const fx = foilX();
    const fh = bottomY - topY;
    const num = Math.max(12, Math.round(fh/20));
    for (let i=0;i<num;i++) {
      nuclei.push({
        x: fx + (Math.random()-0.5)*18,
        y: topY + Math.random()*fh
      });
    }
  }

  // draw static background and source/detector markers
  function drawBackground() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // detector arc on right
    const cx = detectorX();
    const cy = canvas.height/2;
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(0,200,120,0.12)';
    ctx.lineWidth = 3;
    ctx.arc(cx, cy, Math.min(canvas.height*0.42,canvas.width*0.18), -Math.PI/2, Math.PI/2);
    ctx.stroke();

    // source block
    ctx.fillStyle = '#ff7a00';
    ctx.fillRect(beamX-18, canvas.height/2 - 28, 16, 56);
  }

  function drawFoil() {
    if (particles.length===0) return;
    const topY = Math.min(...particles.map(p=>p.y)) - 6;
    const bottomY = Math.max(...particles.map(p=>p.y)) + 6;
    const fx = foilX();
    // foil rectangle (gold)
    ctx.fillStyle = 'rgba(212,175,55,0.92)';
    ctx.fillRect(fx - foilThickness/2, topY, foilThickness, bottomY-topY);
    // nuclei visual
    for (let n of nuclei) {
      ctx.beginPath();
      ctx.fillStyle = '#ffd700';
      ctx.arc(n.x, n.y, 4, 0, Math.PI*2);
      ctx.fill();
    }
    // border
    ctx.strokeStyle = 'rgba(200,150,20,0.9)';
    ctx.lineWidth = 1;
    ctx.strokeRect(fx - foilThickness/2, topY, foilThickness, bottomY-topY);
  }

  // when particle reaches foil plane, apply deterministic outcome based on assigned kind
  function interact(p) {
    if (p.hit) return;
    const fx = foilX();
    if (p.x + p.vx >= fx - foilThickness/2) {
      p.hit = true;
      if (p.kind === 'straight') {
        // minimal disturbance — continue forward with small noise
        p.vx += (Math.random()-0.5)*0.2;
        p.vy += (Math.random()-0.5)*0.2;
        p.color = '#ffd86b';
        counts.straight++;
      } else if (p.kind === 'deflect') {
        // moderately reduce forward speed and add lateral vy
        const lateral = (Math.random() - 0.5) * 2.4; // side deflection
        p.vx *= 0.6 + Math.random()*0.3; // slow down a bit
        p.vy += lateral;
        p.color = '#35f0ff';
        counts.deflected++;
      } else { // bounce
        p.vx = -Math.abs(p.vx) * (0.55 + Math.random()*0.2);
        p.vy += (Math.random()-0.5)*2.5;
        p.color = '#ff4b4b';
        counts.bounced++;
      }
      counts.total++;
      updateCountsUI();
    }
  }

  // update loop
  function step() {
    // fade background for trails
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    drawFoil();

    // update & draw particles
    for (let p of particles) {
      interact(p);
      p.x += p.vx;
      p.y += p.vy;

      // draw particle
      ctx.beginPath();
      ctx.fillStyle = p.color;
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    }

    // draw detector arc on top so it's visible
    const cx = detectorX();
    const cy = canvas.height/2;
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(0,200,120,0.12)';
    ctx.lineWidth = 3;
    ctx.arc(cx, cy, Math.min(canvas.height*0.42,canvas.width*0.18), -Math.PI/2, Math.PI/2);
    ctx.stroke();

    if (running) {
      // recycle particles when they go too far (right or left)
      for (let p of particles) {
        if (p.x > canvas.width + 20 || p.x < -80 || p.y < -80 || p.y > canvas.height + 80) {
          // reset to left retaining same 'kind' distribution or reassign? keep same to keep counts meaningful
          p.x = beamX;
          p.y = p.y; // keep y
          p.vx = speed;
          p.vy = 0;
          p.hit = false;
          p.color = '#ffd86b';
        }
      }
      requestAnimationFrame(step);
    }
  }

  // control handlers
  startBtn.addEventListener('click', () => {
    initParticles();
    drawBackground();
    drawFoil();
    // initial draw of particles
    for (let p of particles) {
      ctx.beginPath();
      ctx.fillStyle = p.color;
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    }
    running = true;
    step();
  });

  resetBtn.addEventListener('click', () => {
    running = false;
    initParticles();
    drawBackground();
    drawFoil();
    // clear counts
    counts = { total:0, straight:0, deflected:0, bounced:0 };
    updateCountsUI();
    // draw initial particles
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    drawBackground();
    drawFoil();
    for (let p of particles) {
      ctx.beginPath();
      ctx.fillStyle = p.color;
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    }
  });

  // initial draw
  drawBackground();
  initParticles();
  drawFoil();
  updateCountsUI();

})();
</script>
</body>
</html>
