<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Lenz's Law Demonstration</title>
    <style>
        body { margin:0; overflow:hidden; background: linear-gradient(to bottom right, #0a0f24, #1a1f3c); font-family:'Segoe UI',sans-serif; }
        #controls { position:absolute; top:10px; left:10px; background: rgba(0,0,0,0.7); padding:20px; border-radius:12px; color:white; }
        #explanation { position:absolute; bottom:20px; left:50%; transform:translateX(-50%); background: rgba(0,0,0,0.7); 
                      padding:20px; border-radius:12px; color:white; max-width:600px; text-align:center; }
        .arrow { color:#ff4444; font-weight:bold; }
    </style>
</head>
<body>
    <div id="controls">
        <h3>Lenz's Law Demonstration</h3>
        <button id="moveButton">Move Magnet</button>
        <p>Direction: <span id="direction">Stationary</span></p>
        <p>Induced Current: <span id="current">None</span></p>
    </div>
    <div id="explanation">
        <p>Lenz's Law: The induced current creates a magnetic field that opposes the change in magnetic flux that created it.</p>
        <p>Red arrows show magnet movement. Blue arrows show induced current direction.</p>
    </div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
let renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
const light = new THREE.PointLight(0xffffff, 1.5);
light.position.set(5, 5, 5);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

// Create coil
function createCoil() {
    const curve = new THREE.Curve();
    curve.getPoint = function(t) {
        const turns = 8;
        const radius = 1.5;  // Larger radius
        const thickness = 0.2;  // Thicker coil
        const angle = t * Math.PI * 2 * turns;
        return new THREE.Vector3(
            0,  // Coil lies in YZ plane
            radius * Math.cos(angle),
            radius * Math.sin(angle)
        );
    };
    const geometry = new THREE.TubeGeometry(curve, 200, thickness, 16, false);
    const material = new THREE.MeshStandardMaterial({
        color: 0xffd700,  // Gold color
        metalness: 0.7,
        roughness: 0.3,
        emissive: 0x222200  // Slight glow
    });
    return new THREE.Mesh(geometry, material);
}

// Create magnet
function createMagnet() {
    const group = new THREE.Group();
    
    // Magnet body
    const geometry = new THREE.CylinderGeometry(0.4, 0.4, 2, 32);
    
    // North pole (red)
    const northMaterial = new THREE.MeshStandardMaterial({
        color: 0xff4444,
        metalness: 0.6,
        roughness: 0.3,
        emissive: 0x441111
    });
    const northPole = new THREE.Mesh(geometry, northMaterial);
    northPole.position.z = 1;
    
    // South pole (blue)
    const southMaterial = new THREE.MeshStandardMaterial({
        color: 0x4444ff,
        metalness: 0.6,
        roughness: 0.3,
        emissive: 0x111144
    });
    const southPole = new THREE.Mesh(geometry, southMaterial);
    southPole.position.z = -1;
    
    // Labels
    const textGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.1);
    const textMatN = new THREE.MeshBasicMaterial({color: 0xffffff});
    const textMatS = new THREE.MeshBasicMaterial({color: 0xffffff});
    const nLabel = new THREE.Mesh(textGeometry, textMatN);
    const sLabel = new THREE.Mesh(textGeometry, textMatS);
    nLabel.position.set(0, 0.5, 1);
    sLabel.position.set(0, 0.5, -1);
    
    group.add(northPole);
    group.add(southPole);
    group.add(nLabel);
    group.add(sLabel);
    
    // Rotate magnet to point along X-axis
    group.rotation.z = Math.PI/2;
    return group;
}

// Create magnetic field lines
function createFieldLines() {
    const group = new THREE.Group();
    const numLines = 12;
    
    for(let i = 0; i < numLines; i++) {
        const angle = (i / numLines) * Math.PI * 2;
        const radius = 0.8;
        
        const curve = new THREE.CubicBezierCurve3(
            new THREE.Vector3(-2, radius * Math.cos(angle), radius * Math.sin(angle)),
            new THREE.Vector3(-0.5, 1.5 * radius * Math.cos(angle), 1.5 * radius * Math.sin(angle)),
            new THREE.Vector3(0.5, 1.5 * radius * Math.cos(angle), 1.5 * radius * Math.sin(angle)),
            new THREE.Vector3(2, radius * Math.cos(angle), radius * Math.sin(angle))
        );
        
        const geometry = new THREE.TubeGeometry(curve, 30, 0.05, 8, false);
        const material = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.6
        });
        const line = new THREE.Mesh(geometry, material);
        group.add(line);
        
        // Add arrows to show field direction
        const arrowGeo = new THREE.ConeGeometry(0.1, 0.3, 8);
        const arrowMat = new THREE.MeshBasicMaterial({color: 0x00ffff});
        const arrow1 = new THREE.Mesh(arrowGeo, arrowMat);
        const arrow2 = new THREE.Mesh(arrowGeo, arrowMat);
        
        arrow1.position.set(1, radius * Math.cos(angle), radius * Math.sin(angle));
        arrow2.position.set(-1, radius * Math.cos(angle), radius * Math.sin(angle));
        arrow1.rotation.z = -Math.PI/2;
        arrow2.rotation.z = Math.PI/2;
        
        group.add(arrow1);
        group.add(arrow2);
    }
    return group;
}

// Create induced current arrows
function createArrows() {
    const group = new THREE.Group();
    const radius = 1.2;
    const numArrows = 8;
    
    for(let i = 0; i < numArrows; i++) {
        const angle = (i / numArrows) * Math.PI * 2;
        const arrowGeo = new THREE.ConeGeometry(0.1, 0.3, 8);
        const arrowMat = new THREE.MeshBasicMaterial({color: 0x00ff00});
        const arrow = new THREE.Mesh(arrowGeo, arrowMat);
        
        arrow.position.set(
            radius * Math.cos(angle),
            radius * Math.sin(angle),
            0
        );
        arrow.rotation.z = angle + Math.PI/2;
        group.add(arrow);
    }
    group.visible = false;
    return group;
}

const coil = createCoil();
const magnet = createMagnet();
const fieldLines = createFieldLines();
const inducedArrows = createArrows();

// Initial positions
magnet.position.x = -4;  // Start from left side
fieldLines.position.x = -4;
coil.rotation.x = Math.PI/2;  // Orient coil vertically

scene.add(coil);
scene.add(magnet);
scene.add(fieldLines);
scene.add(inducedArrows);

// Set up camera for better view
camera.position.set(6, 4, 6);
camera.lookAt(0, 0, 0);

// Add grid for better depth perception
const grid = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
scene.add(grid);

// Animation state
let isMoving = false;
let moveDirection = 1;
let time = 0;

document.getElementById('moveButton').addEventListener('click', () => {
    isMoving = !isMoving;
    if(!isMoving) {
        document.getElementById('direction').textContent = 'Stationary';
        document.getElementById('current').textContent = 'None';
        inducedArrows.visible = false;
    }
});

function animate() {
    requestAnimationFrame(animate);
    
    if(isMoving) {
        time += 0.02;
        const position = Math.sin(time) * 4;  // Larger movement range
        magnet.position.x = position;
        fieldLines.position.x = position;
        
        // Update direction and current indicators
        const movingTowards = Math.cos(time) > 0;
        if(movingTowards) {
            document.getElementById('direction').textContent = 'Moving Right → (Towards Coil)';
            document.getElementById('current').textContent = 'Counter-Clockwise ↺ (Opposing)';
            inducedArrows.visible = true;
            inducedArrows.rotation.x = Math.PI;
        } else {
            document.getElementById('direction').textContent = 'Moving Left ← (Away from Coil)';
            document.getElementById('current').textContent = 'Clockwise ↻ (Opposing)';
            inducedArrows.visible = true;
            inducedArrows.rotation.x = 0;
        }
        
        // Make magnetic field lines pulse with motion
        const pulseScale = 1 + Math.abs(Math.cos(time)) * 0.3;
        fieldLines.scale.y = pulseScale;
        fieldLines.scale.z = pulseScale;
        
        // Scale field lines based on motion
        const scale = 1 + Math.abs(Math.cos(time)) * 0.3;
        fieldLines.scale.set(scale, scale, 1);
    }
    
    renderer.render(scene, camera);
}

animate();

// Handle window resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
