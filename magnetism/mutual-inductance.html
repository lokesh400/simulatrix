<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mutual Induction â€” Bulb Connected</title>
<style>
body { margin:0; overflow:hidden; background: linear-gradient(to bottom right, #0a0f24, #1a1f3c); font-family:'Segoe UI',sans-serif; color:white; }
#controls { position:absolute; top:10px; left:10px; background: rgba(0,0,0,0.5); padding:15px; border-radius:12px; backdrop-filter: blur(10px); }
input[type="range"] { width:180px; }
label { display:block; margin-top:6px; }
</style>
</head>
<body>
<div id="controls">
<h3>Mutual Induction</h3>
<label>Coil Distance:</label>
<input type="range" id="coilSlider" min="1" max="6" step="0.1" value="3">
<label><input type="checkbox" id="autoMove"> Auto Move</label>
<label>Source:
  <select id="srcType">
    <option value="ac">AC</option>
    <option value="dc">DC</option>
  </select>
</label>
<label>AC Amplitude: <span id="ampLabel">1.0</span></label>
<input type="range" id="amp" min="0.1" max="3" step="0.1" value="1">
<label>AC Frequency (Hz): <span id="freqLabel">1.0</span></label>
<input type="range" id="freq" min="0.2" max="5" step="0.1" value="1">
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
const pointLight = new THREE.PointLight(0xffffff, 2); 
pointLight.position.set(5,5,5); 
scene.add(pointLight);

const backLight = new THREE.PointLight(0xffffff, 1);
backLight.position.set(-5,3,-5);
scene.add(backLight);

scene.add(new THREE.AmbientLight(0x404040, 1.5));

// Create copper coil
function createCoil(radius, turns, length) {
  const curve = new THREE.Curve();
  curve.getPoint = function(t){
    const angle = t*Math.PI*2*turns;
    const x = radius*Math.cos(angle);
    const y = radius*Math.sin(angle);
    const z = length*(t-0.5);
    return new THREE.Vector3(x,y,z);
  };
  const geometry = new THREE.TubeGeometry(curve,500,0.05,12,false);
  const material = new THREE.MeshStandardMaterial({ color:0xFFD700, metalness:0.6, roughness:0.3, emissive:0x332200 });
  return new THREE.Mesh(geometry, material);
}

// Coils
const coil1 = createCoil(0.7,8,2);
const coil2 = createCoil(0.7,8,2);
coil1.position.z=-2; coil2.position.z=2;
scene.add(coil1); scene.add(coil2);

// Magnetic field lines
const fieldGroup = new THREE.Group();
for(let i=0;i<20;i++){
  const curve = new THREE.CatmullRomCurve3([
    new THREE.Vector3(0,0,-2.2),
    new THREE.Vector3(Math.cos(i*0.3)*1.5, Math.sin(i*0.3)*1.5,0),
    new THREE.Vector3(0,0,2.2)
  ]);
  const geom = new THREE.TubeGeometry(curve,32,0.01,8,false);
  const mat = new THREE.MeshBasicMaterial({color:0x44ccff});
  const line = new THREE.Mesh(geom,mat);
  fieldGroup.add(line);
}
scene.add(fieldGroup);

// Bulb with glass and filament
const bulbGroup = new THREE.Group();

// Glass bulb
const glassGeom = new THREE.SphereGeometry(0.3, 32, 32);
const glassMat = new THREE.MeshPhysicalMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.2,
    roughness: 0,
    transmission: 0.9,
    thickness: 0.05
});
const glass = new THREE.Mesh(glassGeom, glassMat);

// Bulb base (metal part)
const baseGeom = new THREE.CylinderGeometry(0.15, 0.15, 0.2, 16);
const baseMat = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.8, roughness: 0.2 });
const base = new THREE.Mesh(baseGeom, baseMat);
base.position.y = -0.25;

// Filament
const filamentCurve = new THREE.CatmullRomCurve3([
    new THREE.Vector3(-0.1, -0.1, 0),
    new THREE.Vector3(-0.05, 0.1, 0),
    new THREE.Vector3(0.05, -0.1, 0),
    new THREE.Vector3(0.1, 0.1, 0)
]);
const filamentGeom = new THREE.TubeGeometry(filamentCurve, 20, 0.01, 8, false);
const filamentMat = new THREE.MeshStandardMaterial({ 
    color: 0xff8800,
    emissive: 0xff8800,
    emissiveIntensity: 0
});
const filament = new THREE.Mesh(filamentGeom, filamentMat);

bulbGroup.add(glass, base, filament);
bulbGroup.position.set(0, 2.5, coil2.position.z); // Moved higher above the coil
scene.add(bulbGroup);

// Wires from secondary coil to bulb
function createWire(from,to){
  const dir = new THREE.Vector3().subVectors(to,from);
  const len = dir.length();
  const mid = new THREE.Vector3().addVectors(from,to).multiplyScalar(0.5);
  const geom = new THREE.CylinderGeometry(0.08,0.08,len,16); // Thicker wire with better resolution
  const mat = new THREE.MeshStandardMaterial({
    color: 0xffe7a3, // Slightly golden color
    metalness: 0.9,
    roughness: 0.2,
    emissive: 0x222222 // Slight glow to make it more visible
  });
  const mesh = new THREE.Mesh(geom, mat);
  mesh.position.copy(mid);
  mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
  return mesh;
}
let wire1 = createWire(
    new THREE.Vector3(coil2.position.x, 0.3, coil2.position.z-0.3), // Starting slightly higher on coil
    new THREE.Vector3(bulbGroup.position.x, bulbGroup.position.y-0.3, bulbGroup.position.z-0.15) // Connect to bottom of bulb
);
let wire2 = createWire(
    new THREE.Vector3(coil2.position.x, 0.3, coil2.position.z+0.3),
    new THREE.Vector3(bulbGroup.position.x, bulbGroup.position.y-0.3, bulbGroup.position.z+0.15)
);
scene.add(wire1,wire2);

// Camera
camera.position.set(3,5,0); camera.lookAt(0,0,0);

// Animation variables
let time=0, autoMove=false;
const slider = document.getElementById("coilSlider");
document.getElementById("autoMove").addEventListener("change", e=>autoMove=e.target.checked);

let params = { amp:1, freq:1, srcType:'ac' };
document.getElementById("amp").oninput = e=>{ params.amp=+e.target.value; document.getElementById("ampLabel").innerText=params.amp.toFixed(1); };
document.getElementById("freq").oninput = e=>{ params.freq=+e.target.value; document.getElementById("freqLabel").innerText=params.freq.toFixed(1); };
document.getElementById("srcType").onchange = e=>{ params.srcType=e.target.value; };


function animate(){
  requestAnimationFrame(animate);
  time += 0.03;

  // Coil movement
  if(autoMove){ coil2.position.z = 2 + Math.sin(time)*1.5; slider.value = coil2.position.z; }
  else{ coil2.position.z = parseFloat(slider.value); }

  // Primary current
  let I = (params.srcType==='ac') ? params.amp*Math.sin(2*Math.PI*params.freq*time) : params.amp;

  // Coupling effect by distance
  const dist = Math.abs(coil2.position.z - coil1.position.z);
  const coupling = Math.max(0, 3.0 - dist*0.5);  // Increased coupling factor
  const induced = coupling*I;

  // Enhanced bulb glow effect
  const glow = Math.min(1, Math.abs(induced) * 0.8);  // Increased glow intensity
  filamentMat.emissiveIntensity = glow * 2;  // Double the emissive intensity
  const glowColor = new THREE.Color(0xff8800).lerp(new THREE.Color(0xffffff), glow * 0.7);  // Transition to white at high intensity
  filamentMat.emissive.copy(glowColor);
  glass.material.opacity = 0.2 + glow * 0.3;  // More dramatic glass visibility change
  
  // Add bloom effect to the glass when glowing
  glassMat.emissive.setHex(0xff8800);
  glassMat.emissiveIntensity = glow * 0.3;

  // Update wires to follow coil2
  scene.remove(wire1); scene.remove(wire2);
  
  // Calculate coil end points
  const coilEndOffset = 1; // Length of the coil
  wire1 = createWire(
    new THREE.Vector3(coil2.position.x, 0, coil2.position.z - coilEndOffset), // Back end of coil
    new THREE.Vector3(bulbGroup.position.x, bulbGroup.position.y-0.3, bulbGroup.position.z-0.15)
  );
  wire2 = createWire(
    new THREE.Vector3(coil2.position.x, 0, coil2.position.z + coilEndOffset), // Front end of coil
    new THREE.Vector3(bulbGroup.position.x, bulbGroup.position.y-0.3, bulbGroup.position.z+0.15)
  );
  
  // Add helper connectors at the ends of coil (small vertical pieces)
  const connector1 = createWire(
    new THREE.Vector3(coil2.position.x, -0.2, coil2.position.z - coilEndOffset),
    new THREE.Vector3(coil2.position.x, 0.2, coil2.position.z - coilEndOffset)
  );
  const connector2 = createWire(
    new THREE.Vector3(coil2.position.x, -0.2, coil2.position.z + coilEndOffset),
    new THREE.Vector3(coil2.position.x, 0.2, coil2.position.z + coilEndOffset)
  );
  
  scene.add(wire1, wire2, connector1, connector2);

  // Magnetic field pulsation
  const fieldScale = 1 + 0.15*Math.abs(I);
  fieldGroup.scale.set(fieldScale,fieldScale,1);

  renderer.render(scene,camera);
}


animate();

// Resize
window.addEventListener("resize",()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
