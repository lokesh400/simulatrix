<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PhET-style Wave String Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            max-width: 1000px;
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            margin-top: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to right, #ff7e5f, #feb47b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
        }

        .simulation-area {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 15px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        #stringCanvas {
            width: 100%;
            height: 300px;
            background: radial-gradient(circle at center, #0f1b3a, #050a1a);
            border-radius: 10px;
            display: block;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 10px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        .control-title {
            font-size: 1.1rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #ffcc00;
        }

        .control-title i {
            font-size: 1.3rem;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffcc00;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 204, 0, 0.7);
        }

        .buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 50px;
            background: linear-gradient(to right, #ff7e5f, #feb47b);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            justify-content: center;
            min-width: 140px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }

        button:active {
            transform: translateY(1px);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .preset-btn {
            background: rgba(255, 255, 255, 0.15);
            padding: 10px;
            font-size: 0.9rem;
        }

        .indicators {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .indicator {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 10px;
            min-width: 120px;
        }

        .indicator-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffcc00;
            margin-top: 5px;
        }

        footer {
            margin-top: 30px;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        /* PhET-style tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Wave on a String</h1>
        <p class="subtitle">Explore the physics of wave motion on a string. Adjust tension, damping, and other parameters to see how they affect the wave behavior.</p>
    </header>

    <div class="container">
        <div class="simulation-area">
            <div class="canvas-container">
                <canvas id="stringCanvas" width="950" height="300"></canvas>
            </div>

            <div class="controls">
                <div class="control-group">
                    <div class="control-title">
                        <i>‚öôÔ∏è</i> Wave Properties
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Tension</span>
                            <span id="tensionValue">1.0</span>
                        </div>
                        <input type="range" id="tension" min="0.1" max="2.0" step="0.1" value="1.0">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Damping</span>
                            <span id="dampingValue">0.02</span>
                        </div>
                        <input type="range" id="damping" min="0.0" max="0.1" step="0.01" value="0.02">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Wave Speed</span>
                            <span id="speedValue">1.0</span>
                        </div>
                        <input type="range" id="waveSpeed" min="0.5" max="2.0" step="0.1" value="1.0">
                    </div>
                </div>

                <div class="control-group">
                    <div class="control-title">
                        <i>üéÆ</i> Controls
                    </div>
                    <div class="buttons">
                        <button id="startBtn">
                            <i>‚ñ∂Ô∏è</i> Start
                        </button>
                        <button id="pauseBtn">
                            <i>‚è∏Ô∏è</i> Pause
                        </button>
                        <button id="resetBtn">
                            <i>üîÑ</i> Reset
                        </button>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Amplitude</span>
                            <span id="amplitudeValue">1.0</span>
                        </div>
                        <input type="range" id="amplitude" min="0.1" max="2.0" step="0.1" value="1.0">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Frequency</span>
                            <span id="frequencyValue">1.0</span>
                        </div>
                        <input type="range" id="frequency" min="0.5" max="3.0" step="0.1" value="1.0">
                    </div>
                </div>

                <div class="control-group">
                    <div class="control-title">
                        <i>üîß</i> Preset Waves
                    </div>
                    <div class="preset-buttons">
                        <button class="preset-btn" data-preset="sine">Sine Wave</button>
                        <button class="preset-btn" data-preset="pulse">Pulse</button>
                        <button class="preset-btn" data-preset="triangle">Triangle</button>
                        <button class="preset-btn" data-preset="noise">Noise</button>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Oscillator</span>
                            <span id="oscillatorValue">Off</span>
                        </div>
                        <input type="range" id="oscillator" min="0" max="1" step="1" value="0">
                    </div>
                    <div class="tooltip">
                        <button id="manualPluck">Manual Pluck</button>
                        <span class="tooltiptext">Click and drag on the string to create a custom wave</span>
                    </div>
                </div>
            </div>

            <div class="indicators">
                <div class="indicator">
                    <div>Wave Energy</div>
                    <div class="indicator-value" id="energyValue">0.00</div>
                </div>
                <div class="indicator">
                    <div>Wave Frequency</div>
                    <div class="indicator-value" id="waveFreqValue">0.00 Hz</div>
                </div>
                <div class="indicator">
                    <div>Simulation Time</div>
                    <div class="indicator-value" id="timeValue">0.00 s</div>
                </div>
                <div class="indicator">
                    <div>Wave Points</div>
                    <div class="indicator-value" id="pointsValue">100</div>
                </div>
            </div>
        </div>
    </div>

    <footer>
        <p>PhET-style Wave Simulation | Educational Physics Tool</p>
    </footer>

    <script>
        // String Simulation Class
        class StringSimulator {
            constructor(canvasId, points = 100) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.points = points;
                this.reset();
                this.setupEventListeners();
            }
            
            reset() {
                this.displacement = new Array(this.points).fill(0);
                this.velocity = new Array(this.points).fill(0);
                this.time = 0;
                this.isRunning = false;
                this.animationId = null;
                this.oscillatorEnabled = false;
                this.oscillatorPhase = 0;
                this.draw();
            }
            
            setupEventListeners() {
                // Manual plucking
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.handleMouseUp());
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                this.canvas.addEventListener('touchend', () => this.handleTouchEnd(), { passive: false });
                
                this.isDragging = false;
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            handleMouseDown(e) {
                this.isDragging = true;
                this.pluckAtPosition(this.getMousePos(e));
            }
            
            handleMouseMove(e) {
                if (this.isDragging) {
                    this.pluckAtPosition(this.getMousePos(e));
                }
            }
            
            handleMouseUp() {
                this.isDragging = false;
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                this.isDragging = true;
                this.pluckAtPosition(this.getTouchPos(e));
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                if (this.isDragging) {
                    this.pluckAtPosition(this.getTouchPos(e));
                }
            }
            
            handleTouchEnd() {
                this.isDragging = false;
            }
            
            getTouchPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top
                };
            }
            
            pluckAtPosition(pos) {
                const width = this.canvas.width;
                const pointSpacing = width / (this.points - 1);
                const pointIndex = Math.round(pos.x / pointSpacing);
                
                if (pointIndex >= 1 && pointIndex < this.points - 1) {
                    const amplitude = parseFloat(document.getElementById('amplitude').value);
                    const height = this.canvas.height;
                    const displacement = (height/2 - pos.y) / (height/2) * amplitude;
                    
                    // Create a smooth pluck
                    for (let i = Math.max(1, pointIndex-3); i <= Math.min(this.points-2, pointIndex+3); i++) {
                        const distance = Math.abs(i - pointIndex);
                        const effect = Math.max(0, 1 - distance/4);
                        this.displacement[i] = displacement * effect;
                    }
                }
            }
            
            setPreset(preset) {
                const amplitude = parseFloat(document.getElementById('amplitude').value);
                
                switch(preset) {
                    case 'sine':
                        for (let i = 0; i < this.points; i++) {
                            this.displacement[i] = amplitude * Math.sin(4 * Math.PI * i / this.points);
                        }
                        break;
                    case 'pulse':
                        const center = this.points / 2;
                        for (let i = 0; i < this.points; i++) {
                            const distance = Math.abs(i - center);
                            this.displacement[i] = amplitude * Math.max(0, 1 - distance/10);
                        }
                        break;
                    case 'triangle':
                        for (let i = 0; i < this.points; i++) {
                            const x = i / this.points;
                            this.displacement[i] = amplitude * (x < 0.5 ? 2*x : 2*(1-x));
                        }
                        break;
                    case 'noise':
                        for (let i = 0; i < this.points; i++) {
                            this.displacement[i] = amplitude * (Math.random() * 2 - 1);
                        }
                        break;
                }
                
                this.draw();
            }
            
            step(dt) {
                if (!this.isRunning) return;
                
                const tension = parseFloat(document.getElementById('tension').value);
                const damping = parseFloat(document.getElementById('damping').value);
                const waveSpeed = parseFloat(document.getElementById('waveSpeed').value);
                const frequency = parseFloat(document.getElementById('frequency').value);
                
                const newDisplacement = [...this.displacement];
                const newVelocity = [...this.velocity];
                
                // Apply oscillator if enabled
                if (this.oscillatorEnabled) {
                    const center = Math.floor(this.points / 2);
                    this.oscillatorPhase += dt * frequency * 2 * Math.PI;
                    newDisplacement[center] = parseFloat(document.getElementById('amplitude').value) * Math.sin(this.oscillatorPhase);
                    newVelocity[center] = 0;
                }
                
                for (let i = 1; i < this.points - 1; i++) {
                    // Wave equation: u_tt = c^2 * u_xx - damping * u_t
                    const laplacian = this.displacement[i-1] - 2 * this.displacement[i] + this.displacement[i+1];
                    const acceleration = (waveSpeed * waveSpeed) * tension * laplacian - damping * this.velocity[i];
                    
                    newVelocity[i] += acceleration * dt;
                    newDisplacement[i] += newVelocity[i] * dt;
                }
                
                // Boundary conditions (fixed ends)
                newDisplacement[0] = 0;
                newDisplacement[this.points - 1] = 0;
                newVelocity[0] = 0;
                newVelocity[this.points - 1] = 0;
                
                this.displacement = newDisplacement;
                this.velocity = newVelocity;
                this.time += dt;
                
                this.updateIndicators();
            }
            
            updateIndicators() {
                // Calculate wave energy
                let energy = 0;
                for (let i = 0; i < this.points; i++) {
                    energy += this.velocity[i] * this.velocity[i] + this.displacement[i] * this.displacement[i];
                }
                energy = Math.sqrt(energy / this.points);
                
                document.getElementById('energyValue').textContent = energy.toFixed(3);
                document.getElementById('timeValue').textContent = this.time.toFixed(2);
                
                // Calculate approximate frequency
                let zeroCrossings = 0;
                for (let i = 1; i < this.points; i++) {
                    if (this.displacement[i-1] * this.displacement[i] < 0) {
                        zeroCrossings++;
                    }
                }
                const freq = zeroCrossings / (2 * this.time || 1);
                document.getElementById('waveFreqValue').textContent = freq.toFixed(2) + " Hz";
            }
            
            draw() {
                const ctx = this.ctx;
                const width = this.canvas.width;
                const height = this.canvas.height;
                const pointSpacing = width / (this.points - 1);
                
                // Clear canvas with gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, "#0a0f25");
                gradient.addColorStop(1, "#050a1a");
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                // Draw grid
                ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let x = 0; x < width; x += width/10) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                }
                for (let y = 0; y < height; y += height/10) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                }
                ctx.stroke();
                
                // Draw equilibrium line
                ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height/2);
                ctx.lineTo(width, height/2);
                ctx.stroke();
                
                // Draw string
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                
                for (let i = 0; i < this.points; i++) {
                    const x = i * pointSpacing;
                    const y = height / 2 - this.displacement[i] * 100;
                    ctx.lineTo(x, y);
                }
                
                // Create gradient for the string
                const stringGradient = ctx.createLinearGradient(0, 0, width, 0);
                stringGradient.addColorStop(0, "#ff7e5f");
                stringGradient.addColorStop(0.5, "#feb47b");
                stringGradient.addColorStop(1, "#ff7e5f");
                
                ctx.strokeStyle = stringGradient;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Draw endpoints
                ctx.fillStyle = "#ffcc00";
                ctx.beginPath();
                ctx.arc(0, height/2, 5, 0, Math.PI * 2);
                ctx.arc(width, height/2, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw oscillator if enabled
                if (this.oscillatorEnabled) {
                    const centerX = width / 2;
                    const centerY = height / 2;
                    
                    ctx.fillStyle = "rgba(255, 204, 0, 0.7)";
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = "rgba(255, 204, 0, 0.5)";
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - 70);
                    ctx.lineTo(centerX, centerY + 70);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            start() {
                if (this.isRunning) return;
                this.isRunning = true;
                
                const animate = (timestamp) => {
                    if (!this.isRunning) return;
                    
                    this.step(0.016);
                    this.draw();
                    
                    this.animationId = requestAnimationFrame(animate);
                };
                
                this.animationId = requestAnimationFrame(animate);
            }
            
            pause() {
                this.isRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
            
            setOscillator(enabled) {
                this.oscillatorEnabled = enabled;
                if (!enabled) {
                    this.oscillatorPhase = 0;
                }
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            const simulator = new StringSimulator('stringCanvas');
            
            // Set up control event listeners
            document.getElementById('startBtn').addEventListener('click', () => {
                simulator.start();
            });
            
            document.getElementById('pauseBtn').addEventListener('click', () => {
                simulator.pause();
            });
            
            document.getElementById('resetBtn').addEventListener('click', () => {
                simulator.pause();
                simulator.reset();
            });
            
            document.getElementById('manualPluck').addEventListener('click', () => {
                // Button just enables the functionality already implemented
            });
            
            // Slider event listeners
            const sliders = ['tension', 'damping', 'waveSpeed', 'amplitude', 'frequency', 'oscillator'];
            sliders.forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                const valueElement = document.getElementById(sliderId + 'Value');
                
                slider.addEventListener('input', (e) => {
                    if (sliderId === 'oscillator') {
                        valueElement.textContent = e.target.value === '1' ? 'On' : 'Off';
                        simulator.setOscillator(e.target.value === '1');
                    } else {
                        valueElement.textContent = e.target.value;
                    }
                });
            });
            
            // Preset buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    simulator.setPreset(e.target.dataset.preset);
                });
            });
            
            // Initial draw
            simulator.draw();
        });
    </script>
</body>
</html>