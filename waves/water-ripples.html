<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Water Ripple Interference Simulation</title>
<style>
    body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
    }
    canvas {
        display: block;
    }
</style>
</head>
<body>
<canvas id="rippleCanvas"></canvas>
<script>
const canvas = document.getElementById('rippleCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let sources = [];

class RippleSource {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.time = 0;
        this.frequency = 0.05; // wave frequency
        this.wavelength = 50;  // wave length in pixels
        this.amplitudeDecay = 0.02; // decay with distance
    }

    getAmplitude(x, y) {
        const dx = x - this.x;
        const dy = y - this.y;
        const distance = Math.sqrt(dx*dx + dy*dy);
        // Amplitude decays with distance
        const decay = Math.exp(-this.amplitudeDecay * distance);
        return decay * Math.sin((distance / this.wavelength - this.time) * 2 * Math.PI);
    }

    update() {
        this.time += this.frequency;
    }
}

// Add ripple sources with mouse
canvas.addEventListener('mousedown', (e) => {
    sources.push(new RippleSource(e.clientX, e.clientY));
});

// Optional: drag sources
let dragging = null;
canvas.addEventListener('mousemove', (e) => {
    if (dragging) {
        dragging.x = e.clientX;
        dragging.y = e.clientY;
    }
});
canvas.addEventListener('mouseup', () => dragging = null);
canvas.addEventListener('mousedown', (e) => {
    sources.forEach(s => {
        const dx = e.clientX - s.x;
        const dy = e.clientY - s.y;
        if (Math.sqrt(dx*dx + dy*dy) < 20) {
            dragging = s;
        }
    });
});

// Simulation parameters
const gridSize = 3; // smaller = higher resolution

function animate() {
    const imageData = ctx.createImageData(canvas.width, canvas.height);
    const data = imageData.data;

    for (let y = 0; y < canvas.height; y += gridSize) {
        for (let x = 0; x < canvas.width; x += gridSize) {
            let amplitude = 0;
            sources.forEach(source => {
                amplitude += source.getAmplitude(x, y);
            });
            amplitude = amplitude / (sources.length || 1);

            // Map amplitude to color: constructive = bright, destructive = dark
            const color = Math.floor(128 + amplitude * 127);
            for (let dy = 0; dy < gridSize; dy++) {
                for (let dx = 0; dx < gridSize; dx++) {
                    const px = (x+dx) + (y+dy) * canvas.width;
                    const idx = px * 4;
                    data[idx] = color;      // R
                    data[idx+1] = color;    // G
                    data[idx+2] = 255;      // B
                    data[idx+3] = 255;      // Alpha
                }
            }
        }
    }

    ctx.putImageData(imageData, 0, 0);
    sources.forEach(source => source.update());
    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
